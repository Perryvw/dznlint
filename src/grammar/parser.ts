/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* file := statements={_ statement=root_statement _}* $
* root_statement :=
*   import_statement
*   |interface_definition
*   | component
*   | sl_comment
* sl_comment := text='//[^\n]*\n'
* import_statement := IMPORT _ file_name=file_name _ SEMICOLON
*   file_name := '[^;]+'
* type := enum_definition | int | extern
*   enum_definition := ENUM _ name=identifier _ BRACE_OPEN _ fields=fields _ BRACE_CLOSE _ SEMICOLON
*     fields := {name=identifier _ COMMA? _}*
*   int := SUBINT _ name=compound_name _ BRACE_OPEN _ range=range _ BRACE_CLOSE SEMICOLON
*     range := from=NUMBER _ DOTDOT _ to=NUMBER
*   extern := _ EXTERN _ name=identifier _ value=expression _ SEMICOLON
* namespace := NAMESPACE _ name=compound_name _ BRACE_OPEN root=namespace_root BRACE_CLOSE
*   namespace_root      := statements={_ statement=namespace_statement _}*
*   namespace_statement := type | namespace | interface_definition | component
* interface_definition := INTERFACE _ name=identifier _ BRACE_OPEN _ body={_ type_or_event={type | event} _}* _ behavior=behavior? _ BRACE_CLOSE
*     event := direction _ type_name=identifier _ event_name=identifier  PAREN_OPEN _ PAREN_CLOSE _ SEMICOLON
*       direction := IN | OUT | INOUT
* component := COMPONENT _ name=identifier _ BRACE_OPEN _ ports={_ port=port _}* _ body=body _ BRACE_CLOSE
*   body := behavior | system
*     system := SYSTEM _ BRACE_OPEN _ instances_and_bindings={_ instance_or_binding={instance | binding} _}* _ BRACE_CLOSE
*       instances_and_bindings := {_{instance | binding}_}*
*         instance := type=compound_name _ name=identifier _ SEMICOLON
*         binding := left=end_point _ BIND _ right=end_point _ SEMICOLON
*           end_point := name=expression _ {DOT ASTERISK}? | ASTERISK
*   port := direction=port_direction _ qualifiers=port_qualifiers _ name=compound_name _ arguments=formals? _ identifier _ SEMICOLON
*     port_direction := PROVIDES | REQUIRES
*     port_qualifiers := {_{EXTERNAL | INJECTED}_}*
*     formals := PAREN_OPEN _ {formal COMMA?}* _ PAREN_CLOSE
*       formal := direction? _ type_name=identifier _ name=identifier
* behavior := BEHAVIOR _ name=identifier? _ block=behavior_compound
*   behavior_compound := BRACE_OPEN _ statements=behavior_statements _ BRACE_CLOSE
*     behavior_statements := {_ statement=behavior_statement _}*
*       behavior_statement := port | function_definition | variable_definition | declarative_statement | type
*         function_definition := type_name=identifier _ name=identifier _ formals _ compound
* declarative_statement := on | guard | compound
*   on        := blocking=BLOCKING? _ ON _ expression=expression _ arguments=formals? _ COLON _ statement=imperative_statement
*   guard     := BRACKET_OPEN _ condition={OTHERWISE | expression}? _ BRACKET_CLOSE _ statement=statement
* compound := blocking=BLOCKING? _ BRACE_OPEN _ statements=statements _ BRACE_CLOSE
*   statements  := {_ statement=statement _}*
*   statement   := declarative_statement | imperative_statement
* imperative_statement := variable_definition | assignment | expression_statement | compound
*   assignment            := left=identifier _ ASSIGN _ right=expression _ SEMICOLON
*   expression_statement  := expression=expression SEMICOLON
*   variable_definition   := type_name=compound_name _ name=identifier _ initializer={ASSIGN _ expression=expression _}? SEMICOLON
* expression := property_expression | binary_expression | call_expression | identifier | unary_expression
*   call_expression   := expression=expression _ PAREN_OPEN arguments=arguments PAREN_CLOSE
*     arguments       := {_ expression=expression _ COMMA?}*
*   dollars := DOLLAR value={!DOLLAR}* DOLLAR
*   binary_expression := left=expression _ operator=binary_operator _ right=expression
*     binary_operator := AND | OR | COMPARE
*   property_expression := expression=expression DOT access_name=identifier
*   unary_expression  := operator=unary_operator _ expression=expression
*     unary_operator  := NOT
* compound_name := {compound_name DOT identifier} | identifier
* identifier          := start=@ text='[a-zA-Z_][a-zA-Z0-9_]*' end=@
* NUMBER              := MINUS? '[0-9]+'
* ASTERISK            := '\*'
* DOLLAR              := '\$'
* BRACE_OPEN          := '{'
* BRACE_CLOSE         := '}'
* BRACKET_OPEN        := '\['
* BRACKET_CLOSE       := '\]'
* PAREN_OPEN          := '\('
* PAREN_CLOSE         := '\)'
* SEMICOLON           := ';'
* COLON               := ':'
* DOT                 := '\.'
* DOTDOT              := '\.\.'
* COMMA               := ','
* BIND                := '<=>'
* ASSIGN              := '='
* LEFT_ARROW          := ':='
* OR                  := '||'
* AND                 := '&&'
* EQUAL               := '=='
* NOT_EQUAL           := '!='
* LESS                := '<'
* LESS_EQUAL          := '<='
* GREATER             := '>'
* GREATER_EQUAL       := '>='
* PLUS                := '\+'
* MINUS               := '-'
* NOT                 := '!'
* COMPARE             := EQUAL | NOT_EQUAL | LESS_EQUAL | LESS | GREATER_EQUAL | GREATER
* BEHAVIOR            := 'behavior' | 'behaviour'
* BLOCKING            := 'blocking'
* BOOL                := 'bool'
* COMPONENT           := 'component'
* ELSE                := 'else'
* ENUM                := 'enum'
* EXTERN              := 'extern'
* EXTERNAL            := 'external'
* FALSE               := 'false'
* IF                  := 'if'
* ILLEGAL             := 'illegal'
* IMPORT              := 'import'
* IN                  := 'in'
* INEVITABLE          := 'inevitable'
* INJECTED            := 'injected'
* INOUT               := 'inout'
* INTERFACE           := 'interface'
* NAMESPACE           := 'namespace'
* ON                  := 'on'
* OPTIONAL            := 'optional'
* OTHERWISE           := 'otherwise'
* OUT                 := 'out'
* PROVIDES            := 'provides'
* REPLY               := 'reply'
* REQUIRES            := 'requires'
* RETURN              := 'return'
* SUBINT              := 'subint'
* SYSTEM              := 'system'
* TRUE                := 'true'
* VOID                := 'void'
* NEWLINE             := '\n'
* // Discard whitespace
* _                   := '\s*'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    file = "file",
    file_$0 = "file_$0",
    root_statement_1 = "root_statement_1",
    root_statement_2 = "root_statement_2",
    root_statement_3 = "root_statement_3",
    root_statement_4 = "root_statement_4",
    sl_comment = "sl_comment",
    import_statement = "import_statement",
    file_name = "file_name",
    type_1 = "type_1",
    type_2 = "type_2",
    type_3 = "type_3",
    enum_definition = "enum_definition",
    fields = "fields",
    fields_$0 = "fields_$0",
    int = "int",
    range = "range",
    extern = "extern",
    namespace = "namespace",
    namespace_root = "namespace_root",
    namespace_root_$0 = "namespace_root_$0",
    namespace_statement_1 = "namespace_statement_1",
    namespace_statement_2 = "namespace_statement_2",
    namespace_statement_3 = "namespace_statement_3",
    namespace_statement_4 = "namespace_statement_4",
    interface_definition = "interface_definition",
    interface_definition_$0 = "interface_definition_$0",
    interface_definition_$0_$0_1 = "interface_definition_$0_$0_1",
    interface_definition_$0_$0_2 = "interface_definition_$0_$0_2",
    event = "event",
    direction_1 = "direction_1",
    direction_2 = "direction_2",
    direction_3 = "direction_3",
    component = "component",
    component_$0 = "component_$0",
    body_1 = "body_1",
    body_2 = "body_2",
    system = "system",
    system_$0 = "system_$0",
    system_$0_$0_1 = "system_$0_$0_1",
    system_$0_$0_2 = "system_$0_$0_2",
    instances_and_bindings = "instances_and_bindings",
    instances_and_bindings_$0 = "instances_and_bindings_$0",
    instances_and_bindings_$0_$0_1 = "instances_and_bindings_$0_$0_1",
    instances_and_bindings_$0_$0_2 = "instances_and_bindings_$0_$0_2",
    instance = "instance",
    binding = "binding",
    end_point_1 = "end_point_1",
    end_point_2 = "end_point_2",
    end_point_$0 = "end_point_$0",
    port = "port",
    port_direction_1 = "port_direction_1",
    port_direction_2 = "port_direction_2",
    port_qualifiers = "port_qualifiers",
    port_qualifiers_$0 = "port_qualifiers_$0",
    port_qualifiers_$0_$0_1 = "port_qualifiers_$0_$0_1",
    port_qualifiers_$0_$0_2 = "port_qualifiers_$0_$0_2",
    formals = "formals",
    formals_$0 = "formals_$0",
    formal = "formal",
    behavior = "behavior",
    behavior_compound = "behavior_compound",
    behavior_statements = "behavior_statements",
    behavior_statements_$0 = "behavior_statements_$0",
    behavior_statement_1 = "behavior_statement_1",
    behavior_statement_2 = "behavior_statement_2",
    behavior_statement_3 = "behavior_statement_3",
    behavior_statement_4 = "behavior_statement_4",
    behavior_statement_5 = "behavior_statement_5",
    function_definition = "function_definition",
    declarative_statement_1 = "declarative_statement_1",
    declarative_statement_2 = "declarative_statement_2",
    declarative_statement_3 = "declarative_statement_3",
    on = "on",
    guard = "guard",
    guard_$0_1 = "guard_$0_1",
    guard_$0_2 = "guard_$0_2",
    compound = "compound",
    statements = "statements",
    statements_$0 = "statements_$0",
    statement_1 = "statement_1",
    statement_2 = "statement_2",
    imperative_statement_1 = "imperative_statement_1",
    imperative_statement_2 = "imperative_statement_2",
    imperative_statement_3 = "imperative_statement_3",
    imperative_statement_4 = "imperative_statement_4",
    assignment = "assignment",
    expression_statement = "expression_statement",
    variable_definition = "variable_definition",
    variable_definition_$0 = "variable_definition_$0",
    expression_1 = "expression_1",
    expression_2 = "expression_2",
    expression_3 = "expression_3",
    expression_4 = "expression_4",
    expression_5 = "expression_5",
    call_expression = "call_expression",
    arguments = "arguments",
    arguments_$0 = "arguments_$0",
    dollars = "dollars",
    dollars_$0 = "dollars_$0",
    binary_expression = "binary_expression",
    binary_operator_1 = "binary_operator_1",
    binary_operator_2 = "binary_operator_2",
    binary_operator_3 = "binary_operator_3",
    property_expression = "property_expression",
    unary_expression = "unary_expression",
    unary_operator = "unary_operator",
    compound_name_1 = "compound_name_1",
    compound_name_2 = "compound_name_2",
    compound_name_$0 = "compound_name_$0",
    identifier = "identifier",
    NUMBER = "NUMBER",
    ASTERISK = "ASTERISK",
    DOLLAR = "DOLLAR",
    BRACE_OPEN = "BRACE_OPEN",
    BRACE_CLOSE = "BRACE_CLOSE",
    BRACKET_OPEN = "BRACKET_OPEN",
    BRACKET_CLOSE = "BRACKET_CLOSE",
    PAREN_OPEN = "PAREN_OPEN",
    PAREN_CLOSE = "PAREN_CLOSE",
    SEMICOLON = "SEMICOLON",
    COLON = "COLON",
    DOT = "DOT",
    DOTDOT = "DOTDOT",
    COMMA = "COMMA",
    BIND = "BIND",
    ASSIGN = "ASSIGN",
    LEFT_ARROW = "LEFT_ARROW",
    OR = "OR",
    AND = "AND",
    EQUAL = "EQUAL",
    NOT_EQUAL = "NOT_EQUAL",
    LESS = "LESS",
    LESS_EQUAL = "LESS_EQUAL",
    GREATER = "GREATER",
    GREATER_EQUAL = "GREATER_EQUAL",
    PLUS = "PLUS",
    MINUS = "MINUS",
    NOT = "NOT",
    COMPARE_1 = "COMPARE_1",
    COMPARE_2 = "COMPARE_2",
    COMPARE_3 = "COMPARE_3",
    COMPARE_4 = "COMPARE_4",
    COMPARE_5 = "COMPARE_5",
    COMPARE_6 = "COMPARE_6",
    BEHAVIOR_1 = "BEHAVIOR_1",
    BEHAVIOR_2 = "BEHAVIOR_2",
    BLOCKING = "BLOCKING",
    BOOL = "BOOL",
    COMPONENT = "COMPONENT",
    ELSE = "ELSE",
    ENUM = "ENUM",
    EXTERN = "EXTERN",
    EXTERNAL = "EXTERNAL",
    FALSE = "FALSE",
    IF = "IF",
    ILLEGAL = "ILLEGAL",
    IMPORT = "IMPORT",
    IN = "IN",
    INEVITABLE = "INEVITABLE",
    INJECTED = "INJECTED",
    INOUT = "INOUT",
    INTERFACE = "INTERFACE",
    NAMESPACE = "NAMESPACE",
    ON = "ON",
    OPTIONAL = "OPTIONAL",
    OTHERWISE = "OTHERWISE",
    OUT = "OUT",
    PROVIDES = "PROVIDES",
    REPLY = "REPLY",
    REQUIRES = "REQUIRES",
    RETURN = "RETURN",
    SUBINT = "SUBINT",
    SYSTEM = "SYSTEM",
    TRUE = "TRUE",
    VOID = "VOID",
    NEWLINE = "NEWLINE",
    _ = "_",
    $EOF = "$EOF",
}
export interface file {
    kind: ASTKinds.file;
    statements: file_$0[];
}
export interface file_$0 {
    kind: ASTKinds.file_$0;
    statement: root_statement;
}
export type root_statement = root_statement_1 | root_statement_2 | root_statement_3 | root_statement_4;
export type root_statement_1 = import_statement;
export type root_statement_2 = interface_definition;
export type root_statement_3 = component;
export type root_statement_4 = sl_comment;
export interface sl_comment {
    kind: ASTKinds.sl_comment;
    text: string;
}
export interface import_statement {
    kind: ASTKinds.import_statement;
    file_name: file_name;
}
export type file_name = string;
export type type = type_1 | type_2 | type_3;
export type type_1 = enum_definition;
export type type_2 = int;
export type type_3 = extern;
export interface enum_definition {
    kind: ASTKinds.enum_definition;
    name: identifier;
    fields: fields;
}
export type fields = fields_$0[];
export interface fields_$0 {
    kind: ASTKinds.fields_$0;
    name: identifier;
}
export interface int {
    kind: ASTKinds.int;
    name: compound_name;
    range: range;
}
export interface range {
    kind: ASTKinds.range;
    from: NUMBER;
    to: NUMBER;
}
export interface extern {
    kind: ASTKinds.extern;
    name: identifier;
    value: expression;
}
export interface namespace {
    kind: ASTKinds.namespace;
    name: compound_name;
    root: namespace_root;
}
export interface namespace_root {
    kind: ASTKinds.namespace_root;
    statements: namespace_root_$0[];
}
export interface namespace_root_$0 {
    kind: ASTKinds.namespace_root_$0;
    statement: namespace_statement;
}
export type namespace_statement = namespace_statement_1 | namespace_statement_2 | namespace_statement_3 | namespace_statement_4;
export type namespace_statement_1 = type;
export type namespace_statement_2 = namespace;
export type namespace_statement_3 = interface_definition;
export type namespace_statement_4 = component;
export interface interface_definition {
    kind: ASTKinds.interface_definition;
    name: identifier;
    body: interface_definition_$0[];
    behavior: Nullable<behavior>;
}
export interface interface_definition_$0 {
    kind: ASTKinds.interface_definition_$0;
    type_or_event: interface_definition_$0_$0;
}
export type interface_definition_$0_$0 = interface_definition_$0_$0_1 | interface_definition_$0_$0_2;
export type interface_definition_$0_$0_1 = type;
export type interface_definition_$0_$0_2 = event;
export interface event {
    kind: ASTKinds.event;
    type_name: identifier;
    event_name: identifier;
}
export type direction = direction_1 | direction_2 | direction_3;
export type direction_1 = IN;
export type direction_2 = OUT;
export type direction_3 = INOUT;
export interface component {
    kind: ASTKinds.component;
    name: identifier;
    ports: component_$0[];
    body: body;
}
export interface component_$0 {
    kind: ASTKinds.component_$0;
    port: port;
}
export type body = body_1 | body_2;
export type body_1 = behavior;
export type body_2 = system;
export interface system {
    kind: ASTKinds.system;
    instances_and_bindings: system_$0[];
}
export interface system_$0 {
    kind: ASTKinds.system_$0;
    instance_or_binding: system_$0_$0;
}
export type system_$0_$0 = system_$0_$0_1 | system_$0_$0_2;
export type system_$0_$0_1 = instance;
export type system_$0_$0_2 = binding;
export type instances_and_bindings = instances_and_bindings_$0[];
export interface instances_and_bindings_$0 {
    kind: ASTKinds.instances_and_bindings_$0;
}
export type instances_and_bindings_$0_$0 = instances_and_bindings_$0_$0_1 | instances_and_bindings_$0_$0_2;
export type instances_and_bindings_$0_$0_1 = instance;
export type instances_and_bindings_$0_$0_2 = binding;
export interface instance {
    kind: ASTKinds.instance;
    type: compound_name;
    name: identifier;
}
export interface binding {
    kind: ASTKinds.binding;
    left: end_point;
    right: end_point;
}
export type end_point = end_point_1 | end_point_2;
export interface end_point_1 {
    kind: ASTKinds.end_point_1;
    name: expression;
}
export type end_point_2 = ASTERISK;
export interface end_point_$0 {
    kind: ASTKinds.end_point_$0;
}
export interface port {
    kind: ASTKinds.port;
    direction: port_direction;
    qualifiers: port_qualifiers;
    name: compound_name;
    arguments: Nullable<formals>;
}
export type port_direction = port_direction_1 | port_direction_2;
export type port_direction_1 = PROVIDES;
export type port_direction_2 = REQUIRES;
export type port_qualifiers = port_qualifiers_$0[];
export interface port_qualifiers_$0 {
    kind: ASTKinds.port_qualifiers_$0;
}
export type port_qualifiers_$0_$0 = port_qualifiers_$0_$0_1 | port_qualifiers_$0_$0_2;
export type port_qualifiers_$0_$0_1 = EXTERNAL;
export type port_qualifiers_$0_$0_2 = INJECTED;
export interface formals {
    kind: ASTKinds.formals;
}
export interface formals_$0 {
    kind: ASTKinds.formals_$0;
}
export interface formal {
    kind: ASTKinds.formal;
    type_name: identifier;
    name: identifier;
}
export interface behavior {
    kind: ASTKinds.behavior;
    name: Nullable<identifier>;
    block: behavior_compound;
}
export interface behavior_compound {
    kind: ASTKinds.behavior_compound;
    statements: behavior_statements;
}
export type behavior_statements = behavior_statements_$0[];
export interface behavior_statements_$0 {
    kind: ASTKinds.behavior_statements_$0;
    statement: behavior_statement;
}
export type behavior_statement = behavior_statement_1 | behavior_statement_2 | behavior_statement_3 | behavior_statement_4 | behavior_statement_5;
export type behavior_statement_1 = port;
export type behavior_statement_2 = function_definition;
export type behavior_statement_3 = variable_definition;
export type behavior_statement_4 = declarative_statement;
export type behavior_statement_5 = type;
export interface function_definition {
    kind: ASTKinds.function_definition;
    type_name: identifier;
    name: identifier;
}
export type declarative_statement = declarative_statement_1 | declarative_statement_2 | declarative_statement_3;
export type declarative_statement_1 = on;
export type declarative_statement_2 = guard;
export type declarative_statement_3 = compound;
export interface on {
    kind: ASTKinds.on;
    blocking: Nullable<BLOCKING>;
    expression: expression;
    arguments: Nullable<formals>;
    statement: imperative_statement;
}
export interface guard {
    kind: ASTKinds.guard;
    condition: Nullable<guard_$0>;
    statement: statement;
}
export type guard_$0 = guard_$0_1 | guard_$0_2;
export type guard_$0_1 = OTHERWISE;
export type guard_$0_2 = expression;
export interface compound {
    kind: ASTKinds.compound;
    blocking: Nullable<BLOCKING>;
    statements: statements;
}
export type statements = statements_$0[];
export interface statements_$0 {
    kind: ASTKinds.statements_$0;
    statement: statement;
}
export type statement = statement_1 | statement_2;
export type statement_1 = declarative_statement;
export type statement_2 = imperative_statement;
export type imperative_statement = imperative_statement_1 | imperative_statement_2 | imperative_statement_3 | imperative_statement_4;
export type imperative_statement_1 = variable_definition;
export type imperative_statement_2 = assignment;
export type imperative_statement_3 = expression_statement;
export type imperative_statement_4 = compound;
export interface assignment {
    kind: ASTKinds.assignment;
    left: identifier;
    right: expression;
}
export interface expression_statement {
    kind: ASTKinds.expression_statement;
    expression: expression;
}
export interface variable_definition {
    kind: ASTKinds.variable_definition;
    type_name: compound_name;
    name: identifier;
    initializer: Nullable<variable_definition_$0>;
}
export interface variable_definition_$0 {
    kind: ASTKinds.variable_definition_$0;
    expression: expression;
}
export type expression = expression_1 | expression_2 | expression_3 | expression_4 | expression_5;
export type expression_1 = property_expression;
export type expression_2 = binary_expression;
export type expression_3 = call_expression;
export type expression_4 = identifier;
export type expression_5 = unary_expression;
export interface call_expression {
    kind: ASTKinds.call_expression;
    expression: expression;
    arguments: arguments;
}
export type arguments = arguments_$0[];
export interface arguments_$0 {
    kind: ASTKinds.arguments_$0;
    expression: expression;
}
export interface dollars {
    kind: ASTKinds.dollars;
    value: dollars_$0[];
}
export type dollars_$0 = boolean;
export interface binary_expression {
    kind: ASTKinds.binary_expression;
    left: expression;
    operator: binary_operator;
    right: expression;
}
export type binary_operator = binary_operator_1 | binary_operator_2 | binary_operator_3;
export type binary_operator_1 = AND;
export type binary_operator_2 = OR;
export type binary_operator_3 = COMPARE;
export interface property_expression {
    kind: ASTKinds.property_expression;
    expression: expression;
    access_name: identifier;
}
export interface unary_expression {
    kind: ASTKinds.unary_expression;
    operator: unary_operator;
    expression: expression;
}
export type unary_operator = NOT;
export type compound_name = compound_name_1 | compound_name_2;
export type compound_name_1 = compound_name_$0;
export type compound_name_2 = identifier;
export interface compound_name_$0 {
    kind: ASTKinds.compound_name_$0;
}
export interface identifier {
    kind: ASTKinds.identifier;
    start: PosInfo;
    text: string;
    end: PosInfo;
}
export interface NUMBER {
    kind: ASTKinds.NUMBER;
}
export type ASTERISK = string;
export type DOLLAR = string;
export type BRACE_OPEN = string;
export type BRACE_CLOSE = string;
export type BRACKET_OPEN = string;
export type BRACKET_CLOSE = string;
export type PAREN_OPEN = string;
export type PAREN_CLOSE = string;
export type SEMICOLON = string;
export type COLON = string;
export type DOT = string;
export type DOTDOT = string;
export type COMMA = string;
export type BIND = string;
export type ASSIGN = string;
export type LEFT_ARROW = string;
export type OR = string;
export type AND = string;
export type EQUAL = string;
export type NOT_EQUAL = string;
export type LESS = string;
export type LESS_EQUAL = string;
export type GREATER = string;
export type GREATER_EQUAL = string;
export type PLUS = string;
export type MINUS = string;
export type NOT = string;
export type COMPARE = COMPARE_1 | COMPARE_2 | COMPARE_3 | COMPARE_4 | COMPARE_5 | COMPARE_6;
export type COMPARE_1 = EQUAL;
export type COMPARE_2 = NOT_EQUAL;
export type COMPARE_3 = LESS_EQUAL;
export type COMPARE_4 = LESS;
export type COMPARE_5 = GREATER_EQUAL;
export type COMPARE_6 = GREATER;
export type BEHAVIOR = BEHAVIOR_1 | BEHAVIOR_2;
export type BEHAVIOR_1 = string;
export type BEHAVIOR_2 = string;
export type BLOCKING = string;
export type BOOL = string;
export type COMPONENT = string;
export type ELSE = string;
export type ENUM = string;
export type EXTERN = string;
export type EXTERNAL = string;
export type FALSE = string;
export type IF = string;
export type ILLEGAL = string;
export type IMPORT = string;
export type IN = string;
export type INEVITABLE = string;
export type INJECTED = string;
export type INOUT = string;
export type INTERFACE = string;
export type NAMESPACE = string;
export type ON = string;
export type OPTIONAL = string;
export type OTHERWISE = string;
export type OUT = string;
export type PROVIDES = string;
export type REPLY = string;
export type REQUIRES = string;
export type RETURN = string;
export type SUBINT = string;
export type SYSTEM = string;
export type TRUE = string;
export type VOID = string;
export type NEWLINE = string;
export type _ = string;
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$expression$memo.clear();
        this.$scope$compound_name$memo.clear();
    }
    protected $scope$expression$memo: Map<number, [Nullable<expression>, PosInfo]> = new Map();
    protected $scope$compound_name$memo: Map<number, [Nullable<compound_name>, PosInfo]> = new Map();
    public matchfile($$dpth: number, $$cr?: ErrorTracker): Nullable<file> {
        return this.run<file>($$dpth,
            () => {
                let $scope$statements: Nullable<file_$0[]>;
                let $$res: Nullable<file> = null;
                if (true
                    && ($scope$statements = this.loop<file_$0>(() => this.matchfile_$0($$dpth + 1, $$cr), true)) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.file, statements: $scope$statements};
                }
                return $$res;
            });
    }
    public matchfile_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<file_$0> {
        return this.run<file_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<root_statement>;
                let $$res: Nullable<file_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchroot_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.file_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchroot_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement> {
        return this.choice<root_statement>([
            () => this.matchroot_statement_1($$dpth + 1, $$cr),
            () => this.matchroot_statement_2($$dpth + 1, $$cr),
            () => this.matchroot_statement_3($$dpth + 1, $$cr),
            () => this.matchroot_statement_4($$dpth + 1, $$cr),
        ]);
    }
    public matchroot_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_1> {
        return this.matchimport_statement($$dpth + 1, $$cr);
    }
    public matchroot_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_2> {
        return this.matchinterface_definition($$dpth + 1, $$cr);
    }
    public matchroot_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_3> {
        return this.matchcomponent($$dpth + 1, $$cr);
    }
    public matchroot_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_4> {
        return this.matchsl_comment($$dpth + 1, $$cr);
    }
    public matchsl_comment($$dpth: number, $$cr?: ErrorTracker): Nullable<sl_comment> {
        return this.run<sl_comment>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<sl_comment> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?://[^\n]*\n)`, $$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.sl_comment, text: $scope$text};
                }
                return $$res;
            });
    }
    public matchimport_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<import_statement> {
        return this.run<import_statement>($$dpth,
            () => {
                let $scope$file_name: Nullable<file_name>;
                let $$res: Nullable<import_statement> = null;
                if (true
                    && this.matchIMPORT($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$file_name = this.matchfile_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.import_statement, file_name: $scope$file_name};
                }
                return $$res;
            });
    }
    public matchfile_name($$dpth: number, $$cr?: ErrorTracker): Nullable<file_name> {
        return this.regexAccept(String.raw`(?:[^;]+)`, $$dpth + 1, $$cr);
    }
    public matchtype($$dpth: number, $$cr?: ErrorTracker): Nullable<type> {
        return this.choice<type>([
            () => this.matchtype_1($$dpth + 1, $$cr),
            () => this.matchtype_2($$dpth + 1, $$cr),
            () => this.matchtype_3($$dpth + 1, $$cr),
        ]);
    }
    public matchtype_1($$dpth: number, $$cr?: ErrorTracker): Nullable<type_1> {
        return this.matchenum_definition($$dpth + 1, $$cr);
    }
    public matchtype_2($$dpth: number, $$cr?: ErrorTracker): Nullable<type_2> {
        return this.matchint($$dpth + 1, $$cr);
    }
    public matchtype_3($$dpth: number, $$cr?: ErrorTracker): Nullable<type_3> {
        return this.matchextern($$dpth + 1, $$cr);
    }
    public matchenum_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<enum_definition> {
        return this.run<enum_definition>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $scope$fields: Nullable<fields>;
                let $$res: Nullable<enum_definition> = null;
                if (true
                    && this.matchENUM($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$fields = this.matchfields($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.enum_definition, name: $scope$name, fields: $scope$fields};
                }
                return $$res;
            });
    }
    public matchfields($$dpth: number, $$cr?: ErrorTracker): Nullable<fields> {
        return this.loop<fields_$0>(() => this.matchfields_$0($$dpth + 1, $$cr), true);
    }
    public matchfields_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<fields_$0> {
        return this.run<fields_$0>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<fields_$0> = null;
                if (true
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ((this.matchCOMMA($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.fields_$0, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchint($$dpth: number, $$cr?: ErrorTracker): Nullable<int> {
        return this.run<int>($$dpth,
            () => {
                let $scope$name: Nullable<compound_name>;
                let $scope$range: Nullable<range>;
                let $$res: Nullable<int> = null;
                if (true
                    && this.matchSUBINT($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$range = this.matchrange($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.int, name: $scope$name, range: $scope$range};
                }
                return $$res;
            });
    }
    public matchrange($$dpth: number, $$cr?: ErrorTracker): Nullable<range> {
        return this.run<range>($$dpth,
            () => {
                let $scope$from: Nullable<NUMBER>;
                let $scope$to: Nullable<NUMBER>;
                let $$res: Nullable<range> = null;
                if (true
                    && ($scope$from = this.matchNUMBER($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchDOTDOT($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$to = this.matchNUMBER($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.range, from: $scope$from, to: $scope$to};
                }
                return $$res;
            });
    }
    public matchextern($$dpth: number, $$cr?: ErrorTracker): Nullable<extern> {
        return this.run<extern>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $scope$value: Nullable<expression>;
                let $$res: Nullable<extern> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchEXTERN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$value = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.extern, name: $scope$name, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchnamespace($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace> {
        return this.run<namespace>($$dpth,
            () => {
                let $scope$name: Nullable<compound_name>;
                let $scope$root: Nullable<namespace_root>;
                let $$res: Nullable<namespace> = null;
                if (true
                    && this.matchNAMESPACE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && ($scope$root = this.matchnamespace_root($$dpth + 1, $$cr)) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.namespace, name: $scope$name, root: $scope$root};
                }
                return $$res;
            });
    }
    public matchnamespace_root($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_root> {
        return this.run<namespace_root>($$dpth,
            () => {
                let $scope$statements: Nullable<namespace_root_$0[]>;
                let $$res: Nullable<namespace_root> = null;
                if (true
                    && ($scope$statements = this.loop<namespace_root_$0>(() => this.matchnamespace_root_$0($$dpth + 1, $$cr), true)) !== null
                ) {
                    $$res = {kind: ASTKinds.namespace_root, statements: $scope$statements};
                }
                return $$res;
            });
    }
    public matchnamespace_root_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_root_$0> {
        return this.run<namespace_root_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<namespace_statement>;
                let $$res: Nullable<namespace_root_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchnamespace_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.namespace_root_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchnamespace_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement> {
        return this.choice<namespace_statement>([
            () => this.matchnamespace_statement_1($$dpth + 1, $$cr),
            () => this.matchnamespace_statement_2($$dpth + 1, $$cr),
            () => this.matchnamespace_statement_3($$dpth + 1, $$cr),
            () => this.matchnamespace_statement_4($$dpth + 1, $$cr),
        ]);
    }
    public matchnamespace_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_1> {
        return this.matchtype($$dpth + 1, $$cr);
    }
    public matchnamespace_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_2> {
        return this.matchnamespace($$dpth + 1, $$cr);
    }
    public matchnamespace_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_3> {
        return this.matchinterface_definition($$dpth + 1, $$cr);
    }
    public matchnamespace_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_4> {
        return this.matchcomponent($$dpth + 1, $$cr);
    }
    public matchinterface_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition> {
        return this.run<interface_definition>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $scope$body: Nullable<interface_definition_$0[]>;
                let $scope$behavior: Nullable<Nullable<behavior>>;
                let $$res: Nullable<interface_definition> = null;
                if (true
                    && this.matchINTERFACE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$body = this.loop<interface_definition_$0>(() => this.matchinterface_definition_$0($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$behavior = this.matchbehavior($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.interface_definition, name: $scope$name, body: $scope$body, behavior: $scope$behavior};
                }
                return $$res;
            });
    }
    public matchinterface_definition_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0> {
        return this.run<interface_definition_$0>($$dpth,
            () => {
                let $scope$type_or_event: Nullable<interface_definition_$0_$0>;
                let $$res: Nullable<interface_definition_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$type_or_event = this.matchinterface_definition_$0_$0($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.interface_definition_$0, type_or_event: $scope$type_or_event};
                }
                return $$res;
            });
    }
    public matchinterface_definition_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0_$0> {
        return this.choice<interface_definition_$0_$0>([
            () => this.matchinterface_definition_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchinterface_definition_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchinterface_definition_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0_$0_1> {
        return this.matchtype($$dpth + 1, $$cr);
    }
    public matchinterface_definition_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0_$0_2> {
        return this.matchevent($$dpth + 1, $$cr);
    }
    public matchevent($$dpth: number, $$cr?: ErrorTracker): Nullable<event> {
        return this.run<event>($$dpth,
            () => {
                let $scope$type_name: Nullable<identifier>;
                let $scope$event_name: Nullable<identifier>;
                let $$res: Nullable<event> = null;
                if (true
                    && this.matchdirection($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$type_name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$event_name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.event, type_name: $scope$type_name, event_name: $scope$event_name};
                }
                return $$res;
            });
    }
    public matchdirection($$dpth: number, $$cr?: ErrorTracker): Nullable<direction> {
        return this.choice<direction>([
            () => this.matchdirection_1($$dpth + 1, $$cr),
            () => this.matchdirection_2($$dpth + 1, $$cr),
            () => this.matchdirection_3($$dpth + 1, $$cr),
        ]);
    }
    public matchdirection_1($$dpth: number, $$cr?: ErrorTracker): Nullable<direction_1> {
        return this.matchIN($$dpth + 1, $$cr);
    }
    public matchdirection_2($$dpth: number, $$cr?: ErrorTracker): Nullable<direction_2> {
        return this.matchOUT($$dpth + 1, $$cr);
    }
    public matchdirection_3($$dpth: number, $$cr?: ErrorTracker): Nullable<direction_3> {
        return this.matchINOUT($$dpth + 1, $$cr);
    }
    public matchcomponent($$dpth: number, $$cr?: ErrorTracker): Nullable<component> {
        return this.run<component>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $scope$ports: Nullable<component_$0[]>;
                let $scope$body: Nullable<body>;
                let $$res: Nullable<component> = null;
                if (true
                    && this.matchCOMPONENT($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$ports = this.loop<component_$0>(() => this.matchcomponent_$0($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$body = this.matchbody($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.component, name: $scope$name, ports: $scope$ports, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchcomponent_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<component_$0> {
        return this.run<component_$0>($$dpth,
            () => {
                let $scope$port: Nullable<port>;
                let $$res: Nullable<component_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$port = this.matchport($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.component_$0, port: $scope$port};
                }
                return $$res;
            });
    }
    public matchbody($$dpth: number, $$cr?: ErrorTracker): Nullable<body> {
        return this.choice<body>([
            () => this.matchbody_1($$dpth + 1, $$cr),
            () => this.matchbody_2($$dpth + 1, $$cr),
        ]);
    }
    public matchbody_1($$dpth: number, $$cr?: ErrorTracker): Nullable<body_1> {
        return this.matchbehavior($$dpth + 1, $$cr);
    }
    public matchbody_2($$dpth: number, $$cr?: ErrorTracker): Nullable<body_2> {
        return this.matchsystem($$dpth + 1, $$cr);
    }
    public matchsystem($$dpth: number, $$cr?: ErrorTracker): Nullable<system> {
        return this.run<system>($$dpth,
            () => {
                let $scope$instances_and_bindings: Nullable<system_$0[]>;
                let $$res: Nullable<system> = null;
                if (true
                    && this.matchSYSTEM($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$instances_and_bindings = this.loop<system_$0>(() => this.matchsystem_$0($$dpth + 1, $$cr), true)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.system, instances_and_bindings: $scope$instances_and_bindings};
                }
                return $$res;
            });
    }
    public matchsystem_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0> {
        return this.run<system_$0>($$dpth,
            () => {
                let $scope$instance_or_binding: Nullable<system_$0_$0>;
                let $$res: Nullable<system_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$instance_or_binding = this.matchsystem_$0_$0($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.system_$0, instance_or_binding: $scope$instance_or_binding};
                }
                return $$res;
            });
    }
    public matchsystem_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0_$0> {
        return this.choice<system_$0_$0>([
            () => this.matchsystem_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchsystem_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchsystem_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0_$0_1> {
        return this.matchinstance($$dpth + 1, $$cr);
    }
    public matchsystem_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0_$0_2> {
        return this.matchbinding($$dpth + 1, $$cr);
    }
    public matchinstances_and_bindings($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings> {
        return this.loop<instances_and_bindings_$0>(() => this.matchinstances_and_bindings_$0($$dpth + 1, $$cr), true);
    }
    public matchinstances_and_bindings_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0> {
        return this.run<instances_and_bindings_$0>($$dpth,
            () => {
                let $$res: Nullable<instances_and_bindings_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchinstances_and_bindings_$0_$0($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.instances_and_bindings_$0, };
                }
                return $$res;
            });
    }
    public matchinstances_and_bindings_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0_$0> {
        return this.choice<instances_and_bindings_$0_$0>([
            () => this.matchinstances_and_bindings_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchinstances_and_bindings_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchinstances_and_bindings_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0_$0_1> {
        return this.matchinstance($$dpth + 1, $$cr);
    }
    public matchinstances_and_bindings_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0_$0_2> {
        return this.matchbinding($$dpth + 1, $$cr);
    }
    public matchinstance($$dpth: number, $$cr?: ErrorTracker): Nullable<instance> {
        return this.run<instance>($$dpth,
            () => {
                let $scope$type: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<instance> = null;
                if (true
                    && ($scope$type = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.instance, type: $scope$type, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchbinding($$dpth: number, $$cr?: ErrorTracker): Nullable<binding> {
        return this.run<binding>($$dpth,
            () => {
                let $scope$left: Nullable<end_point>;
                let $scope$right: Nullable<end_point>;
                let $$res: Nullable<binding> = null;
                if (true
                    && ($scope$left = this.matchend_point($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBIND($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchend_point($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.binding, left: $scope$left, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchend_point($$dpth: number, $$cr?: ErrorTracker): Nullable<end_point> {
        return this.choice<end_point>([
            () => this.matchend_point_1($$dpth + 1, $$cr),
            () => this.matchend_point_2($$dpth + 1, $$cr),
        ]);
    }
    public matchend_point_1($$dpth: number, $$cr?: ErrorTracker): Nullable<end_point_1> {
        return this.run<end_point_1>($$dpth,
            () => {
                let $scope$name: Nullable<expression>;
                let $$res: Nullable<end_point_1> = null;
                if (true
                    && ($scope$name = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ((this.matchend_point_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.end_point_1, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchend_point_2($$dpth: number, $$cr?: ErrorTracker): Nullable<end_point_2> {
        return this.matchASTERISK($$dpth + 1, $$cr);
    }
    public matchend_point_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<end_point_$0> {
        return this.run<end_point_$0>($$dpth,
            () => {
                let $$res: Nullable<end_point_$0> = null;
                if (true
                    && this.matchDOT($$dpth + 1, $$cr) !== null
                    && this.matchASTERISK($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.end_point_$0, };
                }
                return $$res;
            });
    }
    public matchport($$dpth: number, $$cr?: ErrorTracker): Nullable<port> {
        return this.run<port>($$dpth,
            () => {
                let $scope$direction: Nullable<port_direction>;
                let $scope$qualifiers: Nullable<port_qualifiers>;
                let $scope$name: Nullable<compound_name>;
                let $scope$arguments: Nullable<Nullable<formals>>;
                let $$res: Nullable<port> = null;
                if (true
                    && ($scope$direction = this.matchport_direction($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$qualifiers = this.matchport_qualifiers($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$arguments = this.matchformals($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchidentifier($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.port, direction: $scope$direction, qualifiers: $scope$qualifiers, name: $scope$name, arguments: $scope$arguments};
                }
                return $$res;
            });
    }
    public matchport_direction($$dpth: number, $$cr?: ErrorTracker): Nullable<port_direction> {
        return this.choice<port_direction>([
            () => this.matchport_direction_1($$dpth + 1, $$cr),
            () => this.matchport_direction_2($$dpth + 1, $$cr),
        ]);
    }
    public matchport_direction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<port_direction_1> {
        return this.matchPROVIDES($$dpth + 1, $$cr);
    }
    public matchport_direction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<port_direction_2> {
        return this.matchREQUIRES($$dpth + 1, $$cr);
    }
    public matchport_qualifiers($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers> {
        return this.loop<port_qualifiers_$0>(() => this.matchport_qualifiers_$0($$dpth + 1, $$cr), true);
    }
    public matchport_qualifiers_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0> {
        return this.run<port_qualifiers_$0>($$dpth,
            () => {
                let $$res: Nullable<port_qualifiers_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchport_qualifiers_$0_$0($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.port_qualifiers_$0, };
                }
                return $$res;
            });
    }
    public matchport_qualifiers_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0_$0> {
        return this.choice<port_qualifiers_$0_$0>([
            () => this.matchport_qualifiers_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchport_qualifiers_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchport_qualifiers_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0_$0_1> {
        return this.matchEXTERNAL($$dpth + 1, $$cr);
    }
    public matchport_qualifiers_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0_$0_2> {
        return this.matchINJECTED($$dpth + 1, $$cr);
    }
    public matchformals($$dpth: number, $$cr?: ErrorTracker): Nullable<formals> {
        return this.run<formals>($$dpth,
            () => {
                let $$res: Nullable<formals> = null;
                if (true
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.loop<formals_$0>(() => this.matchformals_$0($$dpth + 1, $$cr), true) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.formals, };
                }
                return $$res;
            });
    }
    public matchformals_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<formals_$0> {
        return this.run<formals_$0>($$dpth,
            () => {
                let $$res: Nullable<formals_$0> = null;
                if (true
                    && this.matchformal($$dpth + 1, $$cr) !== null
                    && ((this.matchCOMMA($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.formals_$0, };
                }
                return $$res;
            });
    }
    public matchformal($$dpth: number, $$cr?: ErrorTracker): Nullable<formal> {
        return this.run<formal>($$dpth,
            () => {
                let $scope$type_name: Nullable<identifier>;
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<formal> = null;
                if (true
                    && ((this.matchdirection($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$type_name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.formal, type_name: $scope$type_name, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchbehavior($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior> {
        return this.run<behavior>($$dpth,
            () => {
                let $scope$name: Nullable<Nullable<identifier>>;
                let $scope$block: Nullable<behavior_compound>;
                let $$res: Nullable<behavior> = null;
                if (true
                    && this.matchBEHAVIOR($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$name = this.matchidentifier($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$block = this.matchbehavior_compound($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.behavior, name: $scope$name, block: $scope$block};
                }
                return $$res;
            });
    }
    public matchbehavior_compound($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_compound> {
        return this.run<behavior_compound>($$dpth,
            () => {
                let $scope$statements: Nullable<behavior_statements>;
                let $$res: Nullable<behavior_compound> = null;
                if (true
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statements = this.matchbehavior_statements($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.behavior_compound, statements: $scope$statements};
                }
                return $$res;
            });
    }
    public matchbehavior_statements($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statements> {
        return this.loop<behavior_statements_$0>(() => this.matchbehavior_statements_$0($$dpth + 1, $$cr), true);
    }
    public matchbehavior_statements_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statements_$0> {
        return this.run<behavior_statements_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<behavior_statement>;
                let $$res: Nullable<behavior_statements_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchbehavior_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.behavior_statements_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchbehavior_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement> {
        return this.choice<behavior_statement>([
            () => this.matchbehavior_statement_1($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_2($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_3($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_4($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_5($$dpth + 1, $$cr),
        ]);
    }
    public matchbehavior_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_1> {
        return this.matchport($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_2> {
        return this.matchfunction_definition($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_3> {
        return this.matchvariable_definition($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_4> {
        return this.matchdeclarative_statement($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_5($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_5> {
        return this.matchtype($$dpth + 1, $$cr);
    }
    public matchfunction_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<function_definition> {
        return this.run<function_definition>($$dpth,
            () => {
                let $scope$type_name: Nullable<identifier>;
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<function_definition> = null;
                if (true
                    && ($scope$type_name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchformals($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchcompound($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.function_definition, type_name: $scope$type_name, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchdeclarative_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement> {
        return this.choice<declarative_statement>([
            () => this.matchdeclarative_statement_1($$dpth + 1, $$cr),
            () => this.matchdeclarative_statement_2($$dpth + 1, $$cr),
            () => this.matchdeclarative_statement_3($$dpth + 1, $$cr),
        ]);
    }
    public matchdeclarative_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement_1> {
        return this.matchon($$dpth + 1, $$cr);
    }
    public matchdeclarative_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement_2> {
        return this.matchguard($$dpth + 1, $$cr);
    }
    public matchdeclarative_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement_3> {
        return this.matchcompound($$dpth + 1, $$cr);
    }
    public matchon($$dpth: number, $$cr?: ErrorTracker): Nullable<on> {
        return this.run<on>($$dpth,
            () => {
                let $scope$blocking: Nullable<Nullable<BLOCKING>>;
                let $scope$expression: Nullable<expression>;
                let $scope$arguments: Nullable<Nullable<formals>>;
                let $scope$statement: Nullable<imperative_statement>;
                let $$res: Nullable<on> = null;
                if (true
                    && (($scope$blocking = this.matchBLOCKING($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchON($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$arguments = this.matchformals($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchCOLON($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchimperative_statement($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.on, blocking: $scope$blocking, expression: $scope$expression, arguments: $scope$arguments, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchguard($$dpth: number, $$cr?: ErrorTracker): Nullable<guard> {
        return this.run<guard>($$dpth,
            () => {
                let $scope$condition: Nullable<Nullable<guard_$0>>;
                let $scope$statement: Nullable<statement>;
                let $$res: Nullable<guard> = null;
                if (true
                    && this.matchBRACKET_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$condition = this.matchguard_$0($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACKET_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchstatement($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.guard, condition: $scope$condition, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchguard_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<guard_$0> {
        return this.choice<guard_$0>([
            () => this.matchguard_$0_1($$dpth + 1, $$cr),
            () => this.matchguard_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchguard_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<guard_$0_1> {
        return this.matchOTHERWISE($$dpth + 1, $$cr);
    }
    public matchguard_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<guard_$0_2> {
        return this.matchexpression($$dpth + 1, $$cr);
    }
    public matchcompound($$dpth: number, $$cr?: ErrorTracker): Nullable<compound> {
        return this.run<compound>($$dpth,
            () => {
                let $scope$blocking: Nullable<Nullable<BLOCKING>>;
                let $scope$statements: Nullable<statements>;
                let $$res: Nullable<compound> = null;
                if (true
                    && (($scope$blocking = this.matchBLOCKING($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statements = this.matchstatements($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.compound, blocking: $scope$blocking, statements: $scope$statements};
                }
                return $$res;
            });
    }
    public matchstatements($$dpth: number, $$cr?: ErrorTracker): Nullable<statements> {
        return this.loop<statements_$0>(() => this.matchstatements_$0($$dpth + 1, $$cr), true);
    }
    public matchstatements_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<statements_$0> {
        return this.run<statements_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<statement>;
                let $$res: Nullable<statements_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchstatement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.statements_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchstatement($$dpth: number, $$cr?: ErrorTracker): Nullable<statement> {
        return this.choice<statement>([
            () => this.matchstatement_1($$dpth + 1, $$cr),
            () => this.matchstatement_2($$dpth + 1, $$cr),
        ]);
    }
    public matchstatement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<statement_1> {
        return this.matchdeclarative_statement($$dpth + 1, $$cr);
    }
    public matchstatement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<statement_2> {
        return this.matchimperative_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement> {
        return this.choice<imperative_statement>([
            () => this.matchimperative_statement_1($$dpth + 1, $$cr),
            () => this.matchimperative_statement_2($$dpth + 1, $$cr),
            () => this.matchimperative_statement_3($$dpth + 1, $$cr),
            () => this.matchimperative_statement_4($$dpth + 1, $$cr),
        ]);
    }
    public matchimperative_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_1> {
        return this.matchvariable_definition($$dpth + 1, $$cr);
    }
    public matchimperative_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_2> {
        return this.matchassignment($$dpth + 1, $$cr);
    }
    public matchimperative_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_3> {
        return this.matchexpression_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_4> {
        return this.matchcompound($$dpth + 1, $$cr);
    }
    public matchassignment($$dpth: number, $$cr?: ErrorTracker): Nullable<assignment> {
        return this.run<assignment>($$dpth,
            () => {
                let $scope$left: Nullable<identifier>;
                let $scope$right: Nullable<expression>;
                let $$res: Nullable<assignment> = null;
                if (true
                    && ($scope$left = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchASSIGN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.assignment, left: $scope$left, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchexpression_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_statement> {
        return this.run<expression_statement>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<expression_statement> = null;
                if (true
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.expression_statement, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchvariable_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<variable_definition> {
        return this.run<variable_definition>($$dpth,
            () => {
                let $scope$type_name: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $scope$initializer: Nullable<Nullable<variable_definition_$0>>;
                let $$res: Nullable<variable_definition> = null;
                if (true
                    && ($scope$type_name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$initializer = this.matchvariable_definition_$0($$dpth + 1, $$cr)) || true)
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.variable_definition, type_name: $scope$type_name, name: $scope$name, initializer: $scope$initializer};
                }
                return $$res;
            });
    }
    public matchvariable_definition_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<variable_definition_$0> {
        return this.run<variable_definition_$0>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<variable_definition_$0> = null;
                if (true
                    && this.matchASSIGN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.variable_definition_$0, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchexpression($$dpth: number, $$cr?: ErrorTracker): Nullable<expression> {
        const fn = () => {
            return this.choice<expression>([
                () => this.matchexpression_1($$dpth + 1, $$cr),
                () => this.matchexpression_2($$dpth + 1, $$cr),
                () => this.matchexpression_3($$dpth + 1, $$cr),
                () => this.matchexpression_4($$dpth + 1, $$cr),
                () => this.matchexpression_5($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$expression$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$expression$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<expression> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$expression$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchexpression_1($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_1> {
        return this.matchproperty_expression($$dpth + 1, $$cr);
    }
    public matchexpression_2($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_2> {
        return this.matchbinary_expression($$dpth + 1, $$cr);
    }
    public matchexpression_3($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_3> {
        return this.matchcall_expression($$dpth + 1, $$cr);
    }
    public matchexpression_4($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_4> {
        return this.matchidentifier($$dpth + 1, $$cr);
    }
    public matchexpression_5($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_5> {
        return this.matchunary_expression($$dpth + 1, $$cr);
    }
    public matchcall_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<call_expression> {
        return this.run<call_expression>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $scope$arguments: Nullable<arguments>;
                let $$res: Nullable<call_expression> = null;
                if (true
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && ($scope$arguments = this.matcharguments($$dpth + 1, $$cr)) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.call_expression, expression: $scope$expression, arguments: $scope$arguments};
                }
                return $$res;
            });
    }
    public matcharguments($$dpth: number, $$cr?: ErrorTracker): Nullable<arguments> {
        return this.loop<arguments_$0>(() => this.matcharguments_$0($$dpth + 1, $$cr), true);
    }
    public matcharguments_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<arguments_$0> {
        return this.run<arguments_$0>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<arguments_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ((this.matchCOMMA($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.arguments_$0, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchdollars($$dpth: number, $$cr?: ErrorTracker): Nullable<dollars> {
        return this.run<dollars>($$dpth,
            () => {
                let $scope$value: Nullable<dollars_$0[]>;
                let $$res: Nullable<dollars> = null;
                if (true
                    && this.matchDOLLAR($$dpth + 1, $$cr) !== null
                    && ($scope$value = this.loop<dollars_$0>(() => this.matchdollars_$0($$dpth + 1, $$cr), true)) !== null
                    && this.matchDOLLAR($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.dollars, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchdollars_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<dollars_$0> {
        return this.negate(() => this.matchDOLLAR($$dpth + 1, $$cr));
    }
    public matchbinary_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_expression> {
        return this.run<binary_expression>($$dpth,
            () => {
                let $scope$left: Nullable<expression>;
                let $scope$operator: Nullable<binary_operator>;
                let $scope$right: Nullable<expression>;
                let $$res: Nullable<binary_expression> = null;
                if (true
                    && ($scope$left = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$operator = this.matchbinary_operator($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchexpression($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.binary_expression, left: $scope$left, operator: $scope$operator, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchbinary_operator($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator> {
        return this.choice<binary_operator>([
            () => this.matchbinary_operator_1($$dpth + 1, $$cr),
            () => this.matchbinary_operator_2($$dpth + 1, $$cr),
            () => this.matchbinary_operator_3($$dpth + 1, $$cr),
        ]);
    }
    public matchbinary_operator_1($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_1> {
        return this.matchAND($$dpth + 1, $$cr);
    }
    public matchbinary_operator_2($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_2> {
        return this.matchOR($$dpth + 1, $$cr);
    }
    public matchbinary_operator_3($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_3> {
        return this.matchCOMPARE($$dpth + 1, $$cr);
    }
    public matchproperty_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<property_expression> {
        return this.run<property_expression>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $scope$access_name: Nullable<identifier>;
                let $$res: Nullable<property_expression> = null;
                if (true
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.matchDOT($$dpth + 1, $$cr) !== null
                    && ($scope$access_name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.property_expression, expression: $scope$expression, access_name: $scope$access_name};
                }
                return $$res;
            });
    }
    public matchunary_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression> {
        return this.run<unary_expression>($$dpth,
            () => {
                let $scope$operator: Nullable<unary_operator>;
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<unary_expression> = null;
                if (true
                    && ($scope$operator = this.matchunary_operator($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.unary_expression, operator: $scope$operator, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchunary_operator($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_operator> {
        return this.matchNOT($$dpth + 1, $$cr);
    }
    public matchcompound_name($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name> {
        const fn = () => {
            return this.choice<compound_name>([
                () => this.matchcompound_name_1($$dpth + 1, $$cr),
                () => this.matchcompound_name_2($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$compound_name$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$compound_name$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<compound_name> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$compound_name$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchcompound_name_1($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name_1> {
        return this.matchcompound_name_$0($$dpth + 1, $$cr);
    }
    public matchcompound_name_2($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name_2> {
        return this.matchidentifier($$dpth + 1, $$cr);
    }
    public matchcompound_name_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name_$0> {
        return this.run<compound_name_$0>($$dpth,
            () => {
                let $$res: Nullable<compound_name_$0> = null;
                if (true
                    && this.matchcompound_name($$dpth + 1, $$cr) !== null
                    && this.matchDOT($$dpth + 1, $$cr) !== null
                    && this.matchidentifier($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.compound_name_$0, };
                }
                return $$res;
            });
    }
    public matchidentifier($$dpth: number, $$cr?: ErrorTracker): Nullable<identifier> {
        return this.run<identifier>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$text: Nullable<string>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<identifier> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$text = this.regexAccept(String.raw`(?:[a-zA-Z_][a-zA-Z0-9_]*)`, $$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.identifier, start: $scope$start, text: $scope$text, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchNUMBER($$dpth: number, $$cr?: ErrorTracker): Nullable<NUMBER> {
        return this.run<NUMBER>($$dpth,
            () => {
                let $$res: Nullable<NUMBER> = null;
                if (true
                    && ((this.matchMINUS($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[0-9]+)`, $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.NUMBER, };
                }
                return $$res;
            });
    }
    public matchASTERISK($$dpth: number, $$cr?: ErrorTracker): Nullable<ASTERISK> {
        return this.regexAccept(String.raw`(?:\*)`, $$dpth + 1, $$cr);
    }
    public matchDOLLAR($$dpth: number, $$cr?: ErrorTracker): Nullable<DOLLAR> {
        return this.regexAccept(String.raw`(?:\$)`, $$dpth + 1, $$cr);
    }
    public matchBRACE_OPEN($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACE_OPEN> {
        return this.regexAccept(String.raw`(?:{)`, $$dpth + 1, $$cr);
    }
    public matchBRACE_CLOSE($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACE_CLOSE> {
        return this.regexAccept(String.raw`(?:})`, $$dpth + 1, $$cr);
    }
    public matchBRACKET_OPEN($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACKET_OPEN> {
        return this.regexAccept(String.raw`(?:\[)`, $$dpth + 1, $$cr);
    }
    public matchBRACKET_CLOSE($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACKET_CLOSE> {
        return this.regexAccept(String.raw`(?:\])`, $$dpth + 1, $$cr);
    }
    public matchPAREN_OPEN($$dpth: number, $$cr?: ErrorTracker): Nullable<PAREN_OPEN> {
        return this.regexAccept(String.raw`(?:\()`, $$dpth + 1, $$cr);
    }
    public matchPAREN_CLOSE($$dpth: number, $$cr?: ErrorTracker): Nullable<PAREN_CLOSE> {
        return this.regexAccept(String.raw`(?:\))`, $$dpth + 1, $$cr);
    }
    public matchSEMICOLON($$dpth: number, $$cr?: ErrorTracker): Nullable<SEMICOLON> {
        return this.regexAccept(String.raw`(?:;)`, $$dpth + 1, $$cr);
    }
    public matchCOLON($$dpth: number, $$cr?: ErrorTracker): Nullable<COLON> {
        return this.regexAccept(String.raw`(?::)`, $$dpth + 1, $$cr);
    }
    public matchDOT($$dpth: number, $$cr?: ErrorTracker): Nullable<DOT> {
        return this.regexAccept(String.raw`(?:\.)`, $$dpth + 1, $$cr);
    }
    public matchDOTDOT($$dpth: number, $$cr?: ErrorTracker): Nullable<DOTDOT> {
        return this.regexAccept(String.raw`(?:\.\.)`, $$dpth + 1, $$cr);
    }
    public matchCOMMA($$dpth: number, $$cr?: ErrorTracker): Nullable<COMMA> {
        return this.regexAccept(String.raw`(?:,)`, $$dpth + 1, $$cr);
    }
    public matchBIND($$dpth: number, $$cr?: ErrorTracker): Nullable<BIND> {
        return this.regexAccept(String.raw`(?:<=>)`, $$dpth + 1, $$cr);
    }
    public matchASSIGN($$dpth: number, $$cr?: ErrorTracker): Nullable<ASSIGN> {
        return this.regexAccept(String.raw`(?:=)`, $$dpth + 1, $$cr);
    }
    public matchLEFT_ARROW($$dpth: number, $$cr?: ErrorTracker): Nullable<LEFT_ARROW> {
        return this.regexAccept(String.raw`(?::=)`, $$dpth + 1, $$cr);
    }
    public matchOR($$dpth: number, $$cr?: ErrorTracker): Nullable<OR> {
        return this.regexAccept(String.raw`(?:||)`, $$dpth + 1, $$cr);
    }
    public matchAND($$dpth: number, $$cr?: ErrorTracker): Nullable<AND> {
        return this.regexAccept(String.raw`(?:&&)`, $$dpth + 1, $$cr);
    }
    public matchEQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<EQUAL> {
        return this.regexAccept(String.raw`(?:==)`, $$dpth + 1, $$cr);
    }
    public matchNOT_EQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<NOT_EQUAL> {
        return this.regexAccept(String.raw`(?:!=)`, $$dpth + 1, $$cr);
    }
    public matchLESS($$dpth: number, $$cr?: ErrorTracker): Nullable<LESS> {
        return this.regexAccept(String.raw`(?:<)`, $$dpth + 1, $$cr);
    }
    public matchLESS_EQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<LESS_EQUAL> {
        return this.regexAccept(String.raw`(?:<=)`, $$dpth + 1, $$cr);
    }
    public matchGREATER($$dpth: number, $$cr?: ErrorTracker): Nullable<GREATER> {
        return this.regexAccept(String.raw`(?:>)`, $$dpth + 1, $$cr);
    }
    public matchGREATER_EQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<GREATER_EQUAL> {
        return this.regexAccept(String.raw`(?:>=)`, $$dpth + 1, $$cr);
    }
    public matchPLUS($$dpth: number, $$cr?: ErrorTracker): Nullable<PLUS> {
        return this.regexAccept(String.raw`(?:\+)`, $$dpth + 1, $$cr);
    }
    public matchMINUS($$dpth: number, $$cr?: ErrorTracker): Nullable<MINUS> {
        return this.regexAccept(String.raw`(?:-)`, $$dpth + 1, $$cr);
    }
    public matchNOT($$dpth: number, $$cr?: ErrorTracker): Nullable<NOT> {
        return this.regexAccept(String.raw`(?:!)`, $$dpth + 1, $$cr);
    }
    public matchCOMPARE($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE> {
        return this.choice<COMPARE>([
            () => this.matchCOMPARE_1($$dpth + 1, $$cr),
            () => this.matchCOMPARE_2($$dpth + 1, $$cr),
            () => this.matchCOMPARE_3($$dpth + 1, $$cr),
            () => this.matchCOMPARE_4($$dpth + 1, $$cr),
            () => this.matchCOMPARE_5($$dpth + 1, $$cr),
            () => this.matchCOMPARE_6($$dpth + 1, $$cr),
        ]);
    }
    public matchCOMPARE_1($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_1> {
        return this.matchEQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_2($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_2> {
        return this.matchNOT_EQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_3($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_3> {
        return this.matchLESS_EQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_4($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_4> {
        return this.matchLESS($$dpth + 1, $$cr);
    }
    public matchCOMPARE_5($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_5> {
        return this.matchGREATER_EQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_6($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_6> {
        return this.matchGREATER($$dpth + 1, $$cr);
    }
    public matchBEHAVIOR($$dpth: number, $$cr?: ErrorTracker): Nullable<BEHAVIOR> {
        return this.choice<BEHAVIOR>([
            () => this.matchBEHAVIOR_1($$dpth + 1, $$cr),
            () => this.matchBEHAVIOR_2($$dpth + 1, $$cr),
        ]);
    }
    public matchBEHAVIOR_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BEHAVIOR_1> {
        return this.regexAccept(String.raw`(?:behavior)`, $$dpth + 1, $$cr);
    }
    public matchBEHAVIOR_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BEHAVIOR_2> {
        return this.regexAccept(String.raw`(?:behaviour)`, $$dpth + 1, $$cr);
    }
    public matchBLOCKING($$dpth: number, $$cr?: ErrorTracker): Nullable<BLOCKING> {
        return this.regexAccept(String.raw`(?:blocking)`, $$dpth + 1, $$cr);
    }
    public matchBOOL($$dpth: number, $$cr?: ErrorTracker): Nullable<BOOL> {
        return this.regexAccept(String.raw`(?:bool)`, $$dpth + 1, $$cr);
    }
    public matchCOMPONENT($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPONENT> {
        return this.regexAccept(String.raw`(?:component)`, $$dpth + 1, $$cr);
    }
    public matchELSE($$dpth: number, $$cr?: ErrorTracker): Nullable<ELSE> {
        return this.regexAccept(String.raw`(?:else)`, $$dpth + 1, $$cr);
    }
    public matchENUM($$dpth: number, $$cr?: ErrorTracker): Nullable<ENUM> {
        return this.regexAccept(String.raw`(?:enum)`, $$dpth + 1, $$cr);
    }
    public matchEXTERN($$dpth: number, $$cr?: ErrorTracker): Nullable<EXTERN> {
        return this.regexAccept(String.raw`(?:extern)`, $$dpth + 1, $$cr);
    }
    public matchEXTERNAL($$dpth: number, $$cr?: ErrorTracker): Nullable<EXTERNAL> {
        return this.regexAccept(String.raw`(?:external)`, $$dpth + 1, $$cr);
    }
    public matchFALSE($$dpth: number, $$cr?: ErrorTracker): Nullable<FALSE> {
        return this.regexAccept(String.raw`(?:false)`, $$dpth + 1, $$cr);
    }
    public matchIF($$dpth: number, $$cr?: ErrorTracker): Nullable<IF> {
        return this.regexAccept(String.raw`(?:if)`, $$dpth + 1, $$cr);
    }
    public matchILLEGAL($$dpth: number, $$cr?: ErrorTracker): Nullable<ILLEGAL> {
        return this.regexAccept(String.raw`(?:illegal)`, $$dpth + 1, $$cr);
    }
    public matchIMPORT($$dpth: number, $$cr?: ErrorTracker): Nullable<IMPORT> {
        return this.regexAccept(String.raw`(?:import)`, $$dpth + 1, $$cr);
    }
    public matchIN($$dpth: number, $$cr?: ErrorTracker): Nullable<IN> {
        return this.regexAccept(String.raw`(?:in)`, $$dpth + 1, $$cr);
    }
    public matchINEVITABLE($$dpth: number, $$cr?: ErrorTracker): Nullable<INEVITABLE> {
        return this.regexAccept(String.raw`(?:inevitable)`, $$dpth + 1, $$cr);
    }
    public matchINJECTED($$dpth: number, $$cr?: ErrorTracker): Nullable<INJECTED> {
        return this.regexAccept(String.raw`(?:injected)`, $$dpth + 1, $$cr);
    }
    public matchINOUT($$dpth: number, $$cr?: ErrorTracker): Nullable<INOUT> {
        return this.regexAccept(String.raw`(?:inout)`, $$dpth + 1, $$cr);
    }
    public matchINTERFACE($$dpth: number, $$cr?: ErrorTracker): Nullable<INTERFACE> {
        return this.regexAccept(String.raw`(?:interface)`, $$dpth + 1, $$cr);
    }
    public matchNAMESPACE($$dpth: number, $$cr?: ErrorTracker): Nullable<NAMESPACE> {
        return this.regexAccept(String.raw`(?:namespace)`, $$dpth + 1, $$cr);
    }
    public matchON($$dpth: number, $$cr?: ErrorTracker): Nullable<ON> {
        return this.regexAccept(String.raw`(?:on)`, $$dpth + 1, $$cr);
    }
    public matchOPTIONAL($$dpth: number, $$cr?: ErrorTracker): Nullable<OPTIONAL> {
        return this.regexAccept(String.raw`(?:optional)`, $$dpth + 1, $$cr);
    }
    public matchOTHERWISE($$dpth: number, $$cr?: ErrorTracker): Nullable<OTHERWISE> {
        return this.regexAccept(String.raw`(?:otherwise)`, $$dpth + 1, $$cr);
    }
    public matchOUT($$dpth: number, $$cr?: ErrorTracker): Nullable<OUT> {
        return this.regexAccept(String.raw`(?:out)`, $$dpth + 1, $$cr);
    }
    public matchPROVIDES($$dpth: number, $$cr?: ErrorTracker): Nullable<PROVIDES> {
        return this.regexAccept(String.raw`(?:provides)`, $$dpth + 1, $$cr);
    }
    public matchREPLY($$dpth: number, $$cr?: ErrorTracker): Nullable<REPLY> {
        return this.regexAccept(String.raw`(?:reply)`, $$dpth + 1, $$cr);
    }
    public matchREQUIRES($$dpth: number, $$cr?: ErrorTracker): Nullable<REQUIRES> {
        return this.regexAccept(String.raw`(?:requires)`, $$dpth + 1, $$cr);
    }
    public matchRETURN($$dpth: number, $$cr?: ErrorTracker): Nullable<RETURN> {
        return this.regexAccept(String.raw`(?:return)`, $$dpth + 1, $$cr);
    }
    public matchSUBINT($$dpth: number, $$cr?: ErrorTracker): Nullable<SUBINT> {
        return this.regexAccept(String.raw`(?:subint)`, $$dpth + 1, $$cr);
    }
    public matchSYSTEM($$dpth: number, $$cr?: ErrorTracker): Nullable<SYSTEM> {
        return this.regexAccept(String.raw`(?:system)`, $$dpth + 1, $$cr);
    }
    public matchTRUE($$dpth: number, $$cr?: ErrorTracker): Nullable<TRUE> {
        return this.regexAccept(String.raw`(?:true)`, $$dpth + 1, $$cr);
    }
    public matchVOID($$dpth: number, $$cr?: ErrorTracker): Nullable<VOID> {
        return this.regexAccept(String.raw`(?:void)`, $$dpth + 1, $$cr);
    }
    public matchNEWLINE($$dpth: number, $$cr?: ErrorTracker): Nullable<NEWLINE> {
        return this.regexAccept(String.raw`(?:\n)`, $$dpth + 1, $$cr);
    }
    public match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
        return this.regexAccept(String.raw`(?:\s*)`, $$dpth + 1, $$cr);
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchfile(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchfile(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchfile(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    private loop<T>(func: $$RuleType<T>, star: boolean = false): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        for (;;) {
            const t = func();
            if (t === null) {
                break;
            }
            res.push(t);
        }
        if (star || res.length > 0) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y");
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<file>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}