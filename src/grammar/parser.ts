/* AutoGenerated Code, changes may be overwritten
* INPUT GRAMMAR:
* file := _ statements={_ statement=root_statement _}* _ $
* root_statement :=
*   namespace
*   | extern_definition
*   | type_definition
*   | import_statement
*   | interface_definition
*   | component
*   | sl_comment
*   | statement
* extern_definition := EXTERN __ type=identifier __ literal=dollars _ SEMICOLON
* import_statement := IMPORT __ file_name=file_name _ SEMICOLON
*   file_name := '[^;]+'
* type_definition := enum_definition | int | extern_definition
*   enum_definition := ENUM __ name=identifier _ BRACE_OPEN _ fields=fields _ BRACE_CLOSE _ SEMICOLON
*     fields := head=member_identifier? tail={_ COMMA _ elem=member_identifier?}*
*   int := SUBINT __ name=compound_name _ BRACE_OPEN _ range=range _ BRACE_CLOSE _ SEMICOLON
*     range := from=NUMBER _ DOTDOT _ to=NUMBER
* namespace := NAMESPACE __ name=compound_name _ BRACE_OPEN root=namespace_root _ BRACE_CLOSE
*   namespace_root      := statements={_ statement=namespace_statement _}*
*   namespace_statement := type_definition | namespace | interface_definition | component
* interface_definition := INTERFACE __ name=identifier _ BRACE_OPEN _ body={_ type_or_event={type_definition | event} _}* _ behavior=behavior? _ BRACE_CLOSE
*     event := direction=event_direction __ type_name=compound_name __ event_name=identifier _ PAREN_OPEN _ event_params=event_params? _ PAREN_CLOSE _ SEMICOLON
*     event_params := head=event_parameter tail={ _ COMMA _ elem=event_parameter }*
*     event_parameter := direction={direction=param_direction __}? type=compound_name __ name=identifier
*       event_direction := IN | OUT
*       param_direction := INOUT | IN | OUT
* component := COMPONENT c1=__ name=identifier c2=_ BRACE_OPEN c3=_ ports={_ port=port _}* c4=_ body=body? c5=_ BRACE_CLOSE
*   body := behavior | system
*     system := SYSTEM _ BRACE_OPEN _ instances_and_bindings={_ instance_or_binding={instance | binding} _}* _ BRACE_CLOSE
*       instances_and_bindings := {_{instance | binding}_}*
*         instance := type=compound_name _ name=identifier _ SEMICOLON
*         binding := start=@ left=binding_expression _ BIND _ right=binding_expression _ SEMICOLON end=@
*           binding_expression := {start=@ compound=binding_expression DOT name={ asterisk_binding | member_identifier} end=@} | identifier | asterisk_binding
*           asterisk_binding := start=@ ASTERISK end=@
*   port := direction=port_direction __ qualifiers=port_qualifiers? type=compound_name _ name=identifier _ SEMICOLON
*     port_direction := PROVIDES | REQUIRES
*     port_qualifiers := {_ qualifier={EXTERNAL | INJECTED | BLOCKING} __}*
*     formals := PAREN_OPEN _ formals=formal_list? _ PAREN_CLOSE
*       formal_list := head=formal tail={ _ COMMA _ elem=formal }*
*       formal := start=@ direction={direction=param_direction __}? type_name=compound_name __ name=identifier end=@
* behavior := BEHAVIOR _ name=identifier? _ block=behavior_compound
*   behavior_compound := BRACE_OPEN _ statements=behavior_statements _ BRACE_CLOSE
*     behavior_statements := {_ statement=behavior_statement _}*
*       behavior_statement := port | function_definition | variable_definition | declarative_statement | type_definition | sl_comment
*         function_definition := return_type=compound_name _ name=identifier _ parameters=formals _ body=compound
* declarative_statement := on | guard | compound
*   on := start=@ blocking=BLOCKING? _ ON _  on_trigger_list=on_trigger_list _ COLON _ statement=statement end=@
*     on_trigger_list := head=on_trigger? tail={ _ COMMA _ elem=on_trigger }*
*     on_trigger := name=compound_name _ parameters=on_formals?
*     on_formals := PAREN_OPEN _ formals=on_formal_list? _ PAREN_CLOSE
*       on_formal_list := head=on_formal tail={ _ COMMA _ elem=on_formal }*
*         on_formal := name=identifier _ assignment={LEFT_ARROW _ name=identifier}?
*   guard := start=@ blocking=BLOCKING? _ BRACKET_OPEN _ condition={OTHERWISE | expression}? _ BRACKET_CLOSE _ statement=statement end=@
* compound := start=@ blocking=BLOCKING? _ BRACE_OPEN _ statements=statements _ BRACE_CLOSE end=@
*   statements  := {_ statement=statement _}*
*   statement   := declarative_statement | imperative_statement
* imperative_statement :=  if_statement | return_statement | variable_definition | assignment | defer_statement | expression_statement | dollar_statement | compound
*   assignment            := start=@ left=identifier _ ASSIGN _ right=expression _ SEMICOLON end=@
*   defer_statement       := start=@ header=defer_header _ statement=imperative_statement end=@
*     defer_header        := start=@ DEFER _ arguments=defer_arguments? end=@
*     defer_arguments     := PAREN_OPEN arguments=arguments PAREN_CLOSE
*   dollar_statement      := start=@ expression=dollars end=@
*   expression_statement  := start=@ expression=expression SEMICOLON end=@
*   if_statement          := start=@ IF _ PAREN_OPEN _ expression=expression _ PAREN_CLOSE _ statement=imperative_statement _ else_statements=else_statement* end=@
*     else_statement      := ELSE elseif={__ IF _ PAREN_OPEN _ expression=expression _ PAREN_CLOSE}? _ statement=imperative_statement _
*   variable_definition   := start=@ type_name=compound_name _ name=identifier _ initializer={ASSIGN _ expression=expression _}? SEMICOLON end=@
*   return_statement      := start=@ RETURN _ expression=expression? _ SEMICOLON end=@
* expression := binary_expression | unary_expression
*   binary_expression   := left=unary_expression _ operator=binary_operator _ right=expression
*     binary_operator   := AND | OR | EQUAL | NOT_EQUAL | LESS_EQUAL | LESS | GREATER_EQUAL | GREATER | PLUS | MINUS
* unary_expression := parenthesized_expression | property_expression | call_expression | dollars | ILLEGAL | identifier | numeric_literal | unary_operator_expression
*   call_expression             := expression=expression _ PAREN_OPEN arguments=arguments PAREN_CLOSE
*     arguments                 := {_ expression=expression _ COMMA?}*
*   dollars                     := DOLLAR value='[^$]*' DOLLAR
*   numeric_literal             := text=NUMBER
*   parenthesized_expression    := PAREN_OPEN _ expression=expression _ PAREN_CLOSE
*   property_expression         := expression=expression? DOT access_name=member_identifier
*   unary_operator_expression   := operator=unary_operator _ expression=expression
*     unary_operator            := NOT
* compound_name := {start=@ compound=compound_name? DOT name=member_identifier end=@} | identifier
* identifier          := start=@ text='[a-zA-Z_][a-zA-Z0-9_]*' end=@
* member_identifier   := start=@ text='[a-zA-Z0-9_]+' end=@
* NUMBER              := MINUS? '[0-9]+'
* ASTERISK            := '\*'
* DOLLAR              := '\$'
* BRACE_OPEN          := '{'
* BRACE_CLOSE         := '}'
* BRACKET_OPEN        := '\['
* BRACKET_CLOSE       := '\]'
* PAREN_OPEN          := '\('
* PAREN_CLOSE         := '\)'
* SEMICOLON           := ';'
* COLON               := ':'
* DOT                 := '\.'
* DOTDOT              := '\.\.'
* COMMA               := ','
* BIND                := '<=>'
* ASSIGN              := '='
* LEFT_ARROW          := '<-'
* OR                  := '\|\|'
* AND                 := '&&'
* EQUAL               := '=='
* NOT_EQUAL           := '!='
* LESS                := '<'
* LESS_EQUAL          := '<='
* GREATER             := '>'
* GREATER_EQUAL       := '>='
* PLUS                := '\+'
* MINUS               := '-'
* NOT                 := '!'
* COMPARE             := EQUAL | NOT_EQUAL | LESS_EQUAL | LESS | GREATER_EQUAL | GREATER
* BEHAVIOR            := 'behavior' | 'behaviour'
* BLOCKING            := 'blocking'
* BOOL                := 'bool'
* COMPONENT           := 'component'
* DEFER               := 'defer'
* ELSE                := 'else'
* ENUM                := 'enum'
* EXTERN              := 'extern'
* EXTERNAL            := 'external'
* FALSE               := 'false'
* IF                  := 'if'
* ILLEGAL             := start=@ 'illegal' end=@
* IMPORT              := 'import'
* IN                  := 'in'
* INEVITABLE          := 'inevitable'
* INJECTED            := 'injected'
* INOUT               := 'inout'
* INTERFACE           := 'interface'
* NAMESPACE           := 'namespace'
* ON                  := 'on'
* OPTIONAL            := 'optional'
* OTHERWISE           := 'otherwise'
* OUT                 := 'out'
* PROVIDES            := 'provides'
* REPLY               := 'reply'
* REQUIRES            := 'requires'
* RETURN              := 'return'
* SUBINT              := 'subint'
* SYSTEM              := 'system'
* TRUE                := 'true'
* VOID                := 'void'
* NEWLINE             := '\n'
* sl_comment          := text='//[^\n]*' {'\n' | $}
* ml_comment          := '/\*' text={!ml_comment_end '.'}* ml_comment_end
*   ml_comment_end    := '\*' '/'
* _                   := {'\s*' sl_comment _} | {'\s*' ml_comment _} | '\s*'
* __                  := {'\s*' sl_comment _} | {'\s*' ml_comment _} | '\s+'
*/
type Nullable<T> = T | null;
type $$RuleType<T> = () => Nullable<T>;
export interface ASTNodeIntf {
    kind: ASTKinds;
}
export enum ASTKinds {
    file = "file",
    file_$0 = "file_$0",
    root_statement_1 = "root_statement_1",
    root_statement_2 = "root_statement_2",
    root_statement_3 = "root_statement_3",
    root_statement_4 = "root_statement_4",
    root_statement_5 = "root_statement_5",
    root_statement_6 = "root_statement_6",
    root_statement_7 = "root_statement_7",
    root_statement_8 = "root_statement_8",
    extern_definition = "extern_definition",
    import_statement = "import_statement",
    file_name = "file_name",
    type_definition_1 = "type_definition_1",
    type_definition_2 = "type_definition_2",
    type_definition_3 = "type_definition_3",
    enum_definition = "enum_definition",
    fields = "fields",
    fields_$0 = "fields_$0",
    int = "int",
    range = "range",
    namespace = "namespace",
    namespace_root = "namespace_root",
    namespace_root_$0 = "namespace_root_$0",
    namespace_statement_1 = "namespace_statement_1",
    namespace_statement_2 = "namespace_statement_2",
    namespace_statement_3 = "namespace_statement_3",
    namespace_statement_4 = "namespace_statement_4",
    interface_definition = "interface_definition",
    interface_definition_$0 = "interface_definition_$0",
    interface_definition_$0_$0_1 = "interface_definition_$0_$0_1",
    interface_definition_$0_$0_2 = "interface_definition_$0_$0_2",
    event = "event",
    event_params = "event_params",
    event_params_$0 = "event_params_$0",
    event_parameter = "event_parameter",
    event_parameter_$0 = "event_parameter_$0",
    event_direction_1 = "event_direction_1",
    event_direction_2 = "event_direction_2",
    param_direction_1 = "param_direction_1",
    param_direction_2 = "param_direction_2",
    param_direction_3 = "param_direction_3",
    component = "component",
    component_$0 = "component_$0",
    body_1 = "body_1",
    body_2 = "body_2",
    system = "system",
    system_$0 = "system_$0",
    system_$0_$0_1 = "system_$0_$0_1",
    system_$0_$0_2 = "system_$0_$0_2",
    instances_and_bindings = "instances_and_bindings",
    instances_and_bindings_$0 = "instances_and_bindings_$0",
    instances_and_bindings_$0_$0_1 = "instances_and_bindings_$0_$0_1",
    instances_and_bindings_$0_$0_2 = "instances_and_bindings_$0_$0_2",
    instance = "instance",
    binding = "binding",
    binding_expression_1 = "binding_expression_1",
    binding_expression_2 = "binding_expression_2",
    binding_expression_3 = "binding_expression_3",
    binding_expression_$0 = "binding_expression_$0",
    binding_expression_$0_$0_1 = "binding_expression_$0_$0_1",
    binding_expression_$0_$0_2 = "binding_expression_$0_$0_2",
    asterisk_binding = "asterisk_binding",
    port = "port",
    port_direction_1 = "port_direction_1",
    port_direction_2 = "port_direction_2",
    port_qualifiers = "port_qualifiers",
    port_qualifiers_$0 = "port_qualifiers_$0",
    port_qualifiers_$0_$0_1 = "port_qualifiers_$0_$0_1",
    port_qualifiers_$0_$0_2 = "port_qualifiers_$0_$0_2",
    port_qualifiers_$0_$0_3 = "port_qualifiers_$0_$0_3",
    formals = "formals",
    formal_list = "formal_list",
    formal_list_$0 = "formal_list_$0",
    formal = "formal",
    formal_$0 = "formal_$0",
    behavior = "behavior",
    behavior_compound = "behavior_compound",
    behavior_statements = "behavior_statements",
    behavior_statements_$0 = "behavior_statements_$0",
    behavior_statement_1 = "behavior_statement_1",
    behavior_statement_2 = "behavior_statement_2",
    behavior_statement_3 = "behavior_statement_3",
    behavior_statement_4 = "behavior_statement_4",
    behavior_statement_5 = "behavior_statement_5",
    behavior_statement_6 = "behavior_statement_6",
    function_definition = "function_definition",
    declarative_statement_1 = "declarative_statement_1",
    declarative_statement_2 = "declarative_statement_2",
    declarative_statement_3 = "declarative_statement_3",
    on = "on",
    on_trigger_list = "on_trigger_list",
    on_trigger_list_$0 = "on_trigger_list_$0",
    on_trigger = "on_trigger",
    on_formals = "on_formals",
    on_formal_list = "on_formal_list",
    on_formal_list_$0 = "on_formal_list_$0",
    on_formal = "on_formal",
    on_formal_$0 = "on_formal_$0",
    guard = "guard",
    guard_$0_1 = "guard_$0_1",
    guard_$0_2 = "guard_$0_2",
    compound = "compound",
    statements = "statements",
    statements_$0 = "statements_$0",
    statement_1 = "statement_1",
    statement_2 = "statement_2",
    imperative_statement_1 = "imperative_statement_1",
    imperative_statement_2 = "imperative_statement_2",
    imperative_statement_3 = "imperative_statement_3",
    imperative_statement_4 = "imperative_statement_4",
    imperative_statement_5 = "imperative_statement_5",
    imperative_statement_6 = "imperative_statement_6",
    imperative_statement_7 = "imperative_statement_7",
    imperative_statement_8 = "imperative_statement_8",
    assignment = "assignment",
    defer_statement = "defer_statement",
    defer_header = "defer_header",
    defer_arguments = "defer_arguments",
    dollar_statement = "dollar_statement",
    expression_statement = "expression_statement",
    if_statement = "if_statement",
    else_statement = "else_statement",
    else_statement_$0 = "else_statement_$0",
    variable_definition = "variable_definition",
    variable_definition_$0 = "variable_definition_$0",
    return_statement = "return_statement",
    expression_1 = "expression_1",
    expression_2 = "expression_2",
    binary_expression = "binary_expression",
    binary_operator_1 = "binary_operator_1",
    binary_operator_2 = "binary_operator_2",
    binary_operator_3 = "binary_operator_3",
    binary_operator_4 = "binary_operator_4",
    binary_operator_5 = "binary_operator_5",
    binary_operator_6 = "binary_operator_6",
    binary_operator_7 = "binary_operator_7",
    binary_operator_8 = "binary_operator_8",
    binary_operator_9 = "binary_operator_9",
    binary_operator_10 = "binary_operator_10",
    unary_expression_1 = "unary_expression_1",
    unary_expression_2 = "unary_expression_2",
    unary_expression_3 = "unary_expression_3",
    unary_expression_4 = "unary_expression_4",
    unary_expression_5 = "unary_expression_5",
    unary_expression_6 = "unary_expression_6",
    unary_expression_7 = "unary_expression_7",
    unary_expression_8 = "unary_expression_8",
    call_expression = "call_expression",
    arguments = "arguments",
    arguments_$0 = "arguments_$0",
    dollars = "dollars",
    numeric_literal = "numeric_literal",
    parenthesized_expression = "parenthesized_expression",
    property_expression = "property_expression",
    unary_operator_expression = "unary_operator_expression",
    unary_operator = "unary_operator",
    compound_name_1 = "compound_name_1",
    compound_name_2 = "compound_name_2",
    compound_name_$0 = "compound_name_$0",
    identifier = "identifier",
    member_identifier = "member_identifier",
    NUMBER = "NUMBER",
    ASTERISK = "ASTERISK",
    DOLLAR = "DOLLAR",
    BRACE_OPEN = "BRACE_OPEN",
    BRACE_CLOSE = "BRACE_CLOSE",
    BRACKET_OPEN = "BRACKET_OPEN",
    BRACKET_CLOSE = "BRACKET_CLOSE",
    PAREN_OPEN = "PAREN_OPEN",
    PAREN_CLOSE = "PAREN_CLOSE",
    SEMICOLON = "SEMICOLON",
    COLON = "COLON",
    DOT = "DOT",
    DOTDOT = "DOTDOT",
    COMMA = "COMMA",
    BIND = "BIND",
    ASSIGN = "ASSIGN",
    LEFT_ARROW = "LEFT_ARROW",
    OR = "OR",
    AND = "AND",
    EQUAL = "EQUAL",
    NOT_EQUAL = "NOT_EQUAL",
    LESS = "LESS",
    LESS_EQUAL = "LESS_EQUAL",
    GREATER = "GREATER",
    GREATER_EQUAL = "GREATER_EQUAL",
    PLUS = "PLUS",
    MINUS = "MINUS",
    NOT = "NOT",
    COMPARE_1 = "COMPARE_1",
    COMPARE_2 = "COMPARE_2",
    COMPARE_3 = "COMPARE_3",
    COMPARE_4 = "COMPARE_4",
    COMPARE_5 = "COMPARE_5",
    COMPARE_6 = "COMPARE_6",
    BEHAVIOR_1 = "BEHAVIOR_1",
    BEHAVIOR_2 = "BEHAVIOR_2",
    BLOCKING = "BLOCKING",
    BOOL = "BOOL",
    COMPONENT = "COMPONENT",
    DEFER = "DEFER",
    ELSE = "ELSE",
    ENUM = "ENUM",
    EXTERN = "EXTERN",
    EXTERNAL = "EXTERNAL",
    FALSE = "FALSE",
    IF = "IF",
    ILLEGAL = "ILLEGAL",
    IMPORT = "IMPORT",
    IN = "IN",
    INEVITABLE = "INEVITABLE",
    INJECTED = "INJECTED",
    INOUT = "INOUT",
    INTERFACE = "INTERFACE",
    NAMESPACE = "NAMESPACE",
    ON = "ON",
    OPTIONAL = "OPTIONAL",
    OTHERWISE = "OTHERWISE",
    OUT = "OUT",
    PROVIDES = "PROVIDES",
    REPLY = "REPLY",
    REQUIRES = "REQUIRES",
    RETURN = "RETURN",
    SUBINT = "SUBINT",
    SYSTEM = "SYSTEM",
    TRUE = "TRUE",
    VOID = "VOID",
    NEWLINE = "NEWLINE",
    sl_comment = "sl_comment",
    sl_comment_$0_1 = "sl_comment_$0_1",
    sl_comment_$0_2 = "sl_comment_$0_2",
    ml_comment = "ml_comment",
    ml_comment_$0 = "ml_comment_$0",
    ml_comment_end = "ml_comment_end",
    __1 = "__1",
    __2 = "__2",
    __3 = "__3",
    __$0 = "__$0",
    __$1 = "__$1",
    ___1 = "___1",
    ___2 = "___2",
    ___3 = "___3",
    ___$0 = "___$0",
    ___$1 = "___$1",
    $EOF = "$EOF",
}
export interface file {
    kind: ASTKinds.file;
    statements: file_$0[];
}
export interface file_$0 {
    kind: ASTKinds.file_$0;
    statement: root_statement;
}
export type root_statement = root_statement_1 | root_statement_2 | root_statement_3 | root_statement_4 | root_statement_5 | root_statement_6 | root_statement_7 | root_statement_8;
export type root_statement_1 = namespace;
export type root_statement_2 = extern_definition;
export type root_statement_3 = type_definition;
export type root_statement_4 = import_statement;
export type root_statement_5 = interface_definition;
export type root_statement_6 = component;
export type root_statement_7 = sl_comment;
export type root_statement_8 = statement;
export interface extern_definition {
    kind: ASTKinds.extern_definition;
    type: identifier;
    literal: dollars;
}
export interface import_statement {
    kind: ASTKinds.import_statement;
    file_name: file_name;
}
export type file_name = string;
export type type_definition = type_definition_1 | type_definition_2 | type_definition_3;
export type type_definition_1 = enum_definition;
export type type_definition_2 = int;
export type type_definition_3 = extern_definition;
export interface enum_definition {
    kind: ASTKinds.enum_definition;
    name: identifier;
    fields: fields;
}
export interface fields {
    kind: ASTKinds.fields;
    head: Nullable<member_identifier>;
    tail: fields_$0[];
}
export interface fields_$0 {
    kind: ASTKinds.fields_$0;
    elem: Nullable<member_identifier>;
}
export interface int {
    kind: ASTKinds.int;
    name: compound_name;
    range: range;
}
export interface range {
    kind: ASTKinds.range;
    from: NUMBER;
    to: NUMBER;
}
export interface namespace {
    kind: ASTKinds.namespace;
    name: compound_name;
    root: namespace_root;
}
export interface namespace_root {
    kind: ASTKinds.namespace_root;
    statements: namespace_root_$0[];
}
export interface namespace_root_$0 {
    kind: ASTKinds.namespace_root_$0;
    statement: namespace_statement;
}
export type namespace_statement = namespace_statement_1 | namespace_statement_2 | namespace_statement_3 | namespace_statement_4;
export type namespace_statement_1 = type_definition;
export type namespace_statement_2 = namespace;
export type namespace_statement_3 = interface_definition;
export type namespace_statement_4 = component;
export interface interface_definition {
    kind: ASTKinds.interface_definition;
    name: identifier;
    body: interface_definition_$0[];
    behavior: Nullable<behavior>;
}
export interface interface_definition_$0 {
    kind: ASTKinds.interface_definition_$0;
    type_or_event: interface_definition_$0_$0;
}
export type interface_definition_$0_$0 = interface_definition_$0_$0_1 | interface_definition_$0_$0_2;
export type interface_definition_$0_$0_1 = type_definition;
export type interface_definition_$0_$0_2 = event;
export interface event {
    kind: ASTKinds.event;
    direction: event_direction;
    type_name: compound_name;
    event_name: identifier;
    event_params: Nullable<event_params>;
}
export interface event_params {
    kind: ASTKinds.event_params;
    head: event_parameter;
    tail: event_params_$0[];
}
export interface event_params_$0 {
    kind: ASTKinds.event_params_$0;
    elem: event_parameter;
}
export interface event_parameter {
    kind: ASTKinds.event_parameter;
    direction: Nullable<event_parameter_$0>;
    type: compound_name;
    name: identifier;
}
export interface event_parameter_$0 {
    kind: ASTKinds.event_parameter_$0;
    direction: param_direction;
}
export type event_direction = event_direction_1 | event_direction_2;
export type event_direction_1 = IN;
export type event_direction_2 = OUT;
export type param_direction = param_direction_1 | param_direction_2 | param_direction_3;
export type param_direction_1 = INOUT;
export type param_direction_2 = IN;
export type param_direction_3 = OUT;
export interface component {
    kind: ASTKinds.component;
    c1: __;
    name: identifier;
    c2: _;
    c3: _;
    ports: component_$0[];
    c4: _;
    body: Nullable<body>;
    c5: _;
}
export interface component_$0 {
    kind: ASTKinds.component_$0;
    port: port;
}
export type body = body_1 | body_2;
export type body_1 = behavior;
export type body_2 = system;
export interface system {
    kind: ASTKinds.system;
    instances_and_bindings: system_$0[];
}
export interface system_$0 {
    kind: ASTKinds.system_$0;
    instance_or_binding: system_$0_$0;
}
export type system_$0_$0 = system_$0_$0_1 | system_$0_$0_2;
export type system_$0_$0_1 = instance;
export type system_$0_$0_2 = binding;
export type instances_and_bindings = instances_and_bindings_$0[];
export interface instances_and_bindings_$0 {
    kind: ASTKinds.instances_and_bindings_$0;
}
export type instances_and_bindings_$0_$0 = instances_and_bindings_$0_$0_1 | instances_and_bindings_$0_$0_2;
export type instances_and_bindings_$0_$0_1 = instance;
export type instances_and_bindings_$0_$0_2 = binding;
export interface instance {
    kind: ASTKinds.instance;
    type: compound_name;
    name: identifier;
}
export interface binding {
    kind: ASTKinds.binding;
    start: PosInfo;
    left: binding_expression;
    right: binding_expression;
    end: PosInfo;
}
export type binding_expression = binding_expression_1 | binding_expression_2 | binding_expression_3;
export type binding_expression_1 = binding_expression_$0;
export type binding_expression_2 = identifier;
export type binding_expression_3 = asterisk_binding;
export interface binding_expression_$0 {
    kind: ASTKinds.binding_expression_$0;
    start: PosInfo;
    compound: binding_expression;
    name: binding_expression_$0_$0;
    end: PosInfo;
}
export type binding_expression_$0_$0 = binding_expression_$0_$0_1 | binding_expression_$0_$0_2;
export type binding_expression_$0_$0_1 = asterisk_binding;
export type binding_expression_$0_$0_2 = member_identifier;
export interface asterisk_binding {
    kind: ASTKinds.asterisk_binding;
    start: PosInfo;
    end: PosInfo;
}
export interface port {
    kind: ASTKinds.port;
    direction: port_direction;
    qualifiers: Nullable<port_qualifiers>;
    type: compound_name;
    name: identifier;
}
export type port_direction = port_direction_1 | port_direction_2;
export type port_direction_1 = PROVIDES;
export type port_direction_2 = REQUIRES;
export type port_qualifiers = port_qualifiers_$0[];
export interface port_qualifiers_$0 {
    kind: ASTKinds.port_qualifiers_$0;
    qualifier: port_qualifiers_$0_$0;
}
export type port_qualifiers_$0_$0 = port_qualifiers_$0_$0_1 | port_qualifiers_$0_$0_2 | port_qualifiers_$0_$0_3;
export type port_qualifiers_$0_$0_1 = EXTERNAL;
export type port_qualifiers_$0_$0_2 = INJECTED;
export type port_qualifiers_$0_$0_3 = BLOCKING;
export interface formals {
    kind: ASTKinds.formals;
    formals: Nullable<formal_list>;
}
export interface formal_list {
    kind: ASTKinds.formal_list;
    head: formal;
    tail: formal_list_$0[];
}
export interface formal_list_$0 {
    kind: ASTKinds.formal_list_$0;
    elem: formal;
}
export interface formal {
    kind: ASTKinds.formal;
    start: PosInfo;
    direction: Nullable<formal_$0>;
    type_name: compound_name;
    name: identifier;
    end: PosInfo;
}
export interface formal_$0 {
    kind: ASTKinds.formal_$0;
    direction: param_direction;
}
export interface behavior {
    kind: ASTKinds.behavior;
    name: Nullable<identifier>;
    block: behavior_compound;
}
export interface behavior_compound {
    kind: ASTKinds.behavior_compound;
    statements: behavior_statements;
}
export type behavior_statements = behavior_statements_$0[];
export interface behavior_statements_$0 {
    kind: ASTKinds.behavior_statements_$0;
    statement: behavior_statement;
}
export type behavior_statement = behavior_statement_1 | behavior_statement_2 | behavior_statement_3 | behavior_statement_4 | behavior_statement_5 | behavior_statement_6;
export type behavior_statement_1 = port;
export type behavior_statement_2 = function_definition;
export type behavior_statement_3 = variable_definition;
export type behavior_statement_4 = declarative_statement;
export type behavior_statement_5 = type_definition;
export type behavior_statement_6 = sl_comment;
export interface function_definition {
    kind: ASTKinds.function_definition;
    return_type: compound_name;
    name: identifier;
    parameters: formals;
    body: compound;
}
export type declarative_statement = declarative_statement_1 | declarative_statement_2 | declarative_statement_3;
export type declarative_statement_1 = on;
export type declarative_statement_2 = guard;
export type declarative_statement_3 = compound;
export interface on {
    kind: ASTKinds.on;
    start: PosInfo;
    blocking: Nullable<BLOCKING>;
    on_trigger_list: on_trigger_list;
    statement: statement;
    end: PosInfo;
}
export interface on_trigger_list {
    kind: ASTKinds.on_trigger_list;
    head: Nullable<on_trigger>;
    tail: on_trigger_list_$0[];
}
export interface on_trigger_list_$0 {
    kind: ASTKinds.on_trigger_list_$0;
    elem: on_trigger;
}
export interface on_trigger {
    kind: ASTKinds.on_trigger;
    name: compound_name;
    parameters: Nullable<on_formals>;
}
export interface on_formals {
    kind: ASTKinds.on_formals;
    formals: Nullable<on_formal_list>;
}
export interface on_formal_list {
    kind: ASTKinds.on_formal_list;
    head: on_formal;
    tail: on_formal_list_$0[];
}
export interface on_formal_list_$0 {
    kind: ASTKinds.on_formal_list_$0;
    elem: on_formal;
}
export interface on_formal {
    kind: ASTKinds.on_formal;
    name: identifier;
    assignment: Nullable<on_formal_$0>;
}
export interface on_formal_$0 {
    kind: ASTKinds.on_formal_$0;
    name: identifier;
}
export interface guard {
    kind: ASTKinds.guard;
    start: PosInfo;
    blocking: Nullable<BLOCKING>;
    condition: Nullable<guard_$0>;
    statement: statement;
    end: PosInfo;
}
export type guard_$0 = guard_$0_1 | guard_$0_2;
export type guard_$0_1 = OTHERWISE;
export type guard_$0_2 = expression;
export interface compound {
    kind: ASTKinds.compound;
    start: PosInfo;
    blocking: Nullable<BLOCKING>;
    statements: statements;
    end: PosInfo;
}
export type statements = statements_$0[];
export interface statements_$0 {
    kind: ASTKinds.statements_$0;
    statement: statement;
}
export type statement = statement_1 | statement_2;
export type statement_1 = declarative_statement;
export type statement_2 = imperative_statement;
export type imperative_statement = imperative_statement_1 | imperative_statement_2 | imperative_statement_3 | imperative_statement_4 | imperative_statement_5 | imperative_statement_6 | imperative_statement_7 | imperative_statement_8;
export type imperative_statement_1 = if_statement;
export type imperative_statement_2 = return_statement;
export type imperative_statement_3 = variable_definition;
export type imperative_statement_4 = assignment;
export type imperative_statement_5 = defer_statement;
export type imperative_statement_6 = expression_statement;
export type imperative_statement_7 = dollar_statement;
export type imperative_statement_8 = compound;
export interface assignment {
    kind: ASTKinds.assignment;
    start: PosInfo;
    left: identifier;
    right: expression;
    end: PosInfo;
}
export interface defer_statement {
    kind: ASTKinds.defer_statement;
    start: PosInfo;
    header: defer_header;
    statement: imperative_statement;
    end: PosInfo;
}
export interface defer_header {
    kind: ASTKinds.defer_header;
    start: PosInfo;
    arguments: Nullable<defer_arguments>;
    end: PosInfo;
}
export interface defer_arguments {
    kind: ASTKinds.defer_arguments;
    arguments: arguments;
}
export interface dollar_statement {
    kind: ASTKinds.dollar_statement;
    start: PosInfo;
    expression: dollars;
    end: PosInfo;
}
export interface expression_statement {
    kind: ASTKinds.expression_statement;
    start: PosInfo;
    expression: expression;
    end: PosInfo;
}
export interface if_statement {
    kind: ASTKinds.if_statement;
    start: PosInfo;
    expression: expression;
    statement: imperative_statement;
    else_statements: else_statement[];
    end: PosInfo;
}
export interface else_statement {
    kind: ASTKinds.else_statement;
    elseif: Nullable<else_statement_$0>;
    statement: imperative_statement;
}
export interface else_statement_$0 {
    kind: ASTKinds.else_statement_$0;
    expression: expression;
}
export interface variable_definition {
    kind: ASTKinds.variable_definition;
    start: PosInfo;
    type_name: compound_name;
    name: identifier;
    initializer: Nullable<variable_definition_$0>;
    end: PosInfo;
}
export interface variable_definition_$0 {
    kind: ASTKinds.variable_definition_$0;
    expression: expression;
}
export interface return_statement {
    kind: ASTKinds.return_statement;
    start: PosInfo;
    expression: Nullable<expression>;
    end: PosInfo;
}
export type expression = expression_1 | expression_2;
export type expression_1 = binary_expression;
export type expression_2 = unary_expression;
export interface binary_expression {
    kind: ASTKinds.binary_expression;
    left: unary_expression;
    operator: binary_operator;
    right: expression;
}
export type binary_operator = binary_operator_1 | binary_operator_2 | binary_operator_3 | binary_operator_4 | binary_operator_5 | binary_operator_6 | binary_operator_7 | binary_operator_8 | binary_operator_9 | binary_operator_10;
export type binary_operator_1 = AND;
export type binary_operator_2 = OR;
export type binary_operator_3 = EQUAL;
export type binary_operator_4 = NOT_EQUAL;
export type binary_operator_5 = LESS_EQUAL;
export type binary_operator_6 = LESS;
export type binary_operator_7 = GREATER_EQUAL;
export type binary_operator_8 = GREATER;
export type binary_operator_9 = PLUS;
export type binary_operator_10 = MINUS;
export type unary_expression = unary_expression_1 | unary_expression_2 | unary_expression_3 | unary_expression_4 | unary_expression_5 | unary_expression_6 | unary_expression_7 | unary_expression_8;
export type unary_expression_1 = parenthesized_expression;
export type unary_expression_2 = property_expression;
export type unary_expression_3 = call_expression;
export type unary_expression_4 = dollars;
export type unary_expression_5 = ILLEGAL;
export type unary_expression_6 = identifier;
export type unary_expression_7 = numeric_literal;
export type unary_expression_8 = unary_operator_expression;
export interface call_expression {
    kind: ASTKinds.call_expression;
    expression: expression;
    arguments: arguments;
}
export type arguments = arguments_$0[];
export interface arguments_$0 {
    kind: ASTKinds.arguments_$0;
    expression: expression;
}
export interface dollars {
    kind: ASTKinds.dollars;
    value: string;
}
export interface numeric_literal {
    kind: ASTKinds.numeric_literal;
    text: NUMBER;
}
export interface parenthesized_expression {
    kind: ASTKinds.parenthesized_expression;
    expression: expression;
}
export interface property_expression {
    kind: ASTKinds.property_expression;
    expression: Nullable<expression>;
    access_name: member_identifier;
}
export interface unary_operator_expression {
    kind: ASTKinds.unary_operator_expression;
    operator: unary_operator;
    expression: expression;
}
export type unary_operator = NOT;
export type compound_name = compound_name_1 | compound_name_2;
export type compound_name_1 = compound_name_$0;
export type compound_name_2 = identifier;
export interface compound_name_$0 {
    kind: ASTKinds.compound_name_$0;
    start: PosInfo;
    compound: Nullable<compound_name>;
    name: member_identifier;
    end: PosInfo;
}
export interface identifier {
    kind: ASTKinds.identifier;
    start: PosInfo;
    text: string;
    end: PosInfo;
}
export interface member_identifier {
    kind: ASTKinds.member_identifier;
    start: PosInfo;
    text: string;
    end: PosInfo;
}
export interface NUMBER {
    kind: ASTKinds.NUMBER;
}
export type ASTERISK = string;
export type DOLLAR = string;
export type BRACE_OPEN = string;
export type BRACE_CLOSE = string;
export type BRACKET_OPEN = string;
export type BRACKET_CLOSE = string;
export type PAREN_OPEN = string;
export type PAREN_CLOSE = string;
export type SEMICOLON = string;
export type COLON = string;
export type DOT = string;
export type DOTDOT = string;
export type COMMA = string;
export type BIND = string;
export type ASSIGN = string;
export type LEFT_ARROW = string;
export type OR = string;
export type AND = string;
export type EQUAL = string;
export type NOT_EQUAL = string;
export type LESS = string;
export type LESS_EQUAL = string;
export type GREATER = string;
export type GREATER_EQUAL = string;
export type PLUS = string;
export type MINUS = string;
export type NOT = string;
export type COMPARE = COMPARE_1 | COMPARE_2 | COMPARE_3 | COMPARE_4 | COMPARE_5 | COMPARE_6;
export type COMPARE_1 = EQUAL;
export type COMPARE_2 = NOT_EQUAL;
export type COMPARE_3 = LESS_EQUAL;
export type COMPARE_4 = LESS;
export type COMPARE_5 = GREATER_EQUAL;
export type COMPARE_6 = GREATER;
export type BEHAVIOR = BEHAVIOR_1 | BEHAVIOR_2;
export type BEHAVIOR_1 = string;
export type BEHAVIOR_2 = string;
export type BLOCKING = string;
export type BOOL = string;
export type COMPONENT = string;
export type DEFER = string;
export type ELSE = string;
export type ENUM = string;
export type EXTERN = string;
export type EXTERNAL = string;
export type FALSE = string;
export type IF = string;
export interface ILLEGAL {
    kind: ASTKinds.ILLEGAL;
    start: PosInfo;
    end: PosInfo;
}
export type IMPORT = string;
export type IN = string;
export type INEVITABLE = string;
export type INJECTED = string;
export type INOUT = string;
export type INTERFACE = string;
export type NAMESPACE = string;
export type ON = string;
export type OPTIONAL = string;
export type OTHERWISE = string;
export type OUT = string;
export type PROVIDES = string;
export type REPLY = string;
export type REQUIRES = string;
export type RETURN = string;
export type SUBINT = string;
export type SYSTEM = string;
export type TRUE = string;
export type VOID = string;
export type NEWLINE = string;
export interface sl_comment {
    kind: ASTKinds.sl_comment;
    text: string;
}
export type sl_comment_$0 = sl_comment_$0_1 | sl_comment_$0_2;
export type sl_comment_$0_1 = string;
export type sl_comment_$0_2 = {kind: ASTKinds.$EOF};
export interface ml_comment {
    kind: ASTKinds.ml_comment;
    text: ml_comment_$0[];
}
export interface ml_comment_$0 {
    kind: ASTKinds.ml_comment_$0;
}
export interface ml_comment_end {
    kind: ASTKinds.ml_comment_end;
}
export type _ = __1 | __2 | __3;
export type __1 = __$0;
export type __2 = __$1;
export type __3 = string;
export interface __$0 {
    kind: ASTKinds.__$0;
}
export interface __$1 {
    kind: ASTKinds.__$1;
}
export type __ = ___1 | ___2 | ___3;
export type ___1 = ___$0;
export type ___2 = ___$1;
export type ___3 = string;
export interface ___$0 {
    kind: ASTKinds.___$0;
}
export interface ___$1 {
    kind: ASTKinds.___$1;
}
export class Parser {
    private readonly input: string;
    private pos: PosInfo;
    private negating: boolean = false;
    private memoSafe: boolean = true;
    constructor(input: string) {
        this.pos = {overallPos: 0, line: 1, offset: 0};
        this.input = input;
    }
    public reset(pos: PosInfo) {
        this.pos = pos;
    }
    public finished(): boolean {
        return this.pos.overallPos === this.input.length;
    }
    public clearMemos(): void {
        this.$scope$binding_expression$memo.clear();
        this.$scope$expression$memo.clear();
        this.$scope$compound_name$memo.clear();
    }
    protected $scope$binding_expression$memo: Map<number, [Nullable<binding_expression>, PosInfo]> = new Map();
    protected $scope$expression$memo: Map<number, [Nullable<expression>, PosInfo]> = new Map();
    protected $scope$compound_name$memo: Map<number, [Nullable<compound_name>, PosInfo]> = new Map();
    public matchfile($$dpth: number, $$cr?: ErrorTracker): Nullable<file> {
        return this.run<file>($$dpth,
            () => {
                let $scope$statements: Nullable<file_$0[]>;
                let $$res: Nullable<file> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statements = this.loop<file_$0>(() => this.matchfile_$0($$dpth + 1, $$cr), 0, -1)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.match$EOF($$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.file, statements: $scope$statements};
                }
                return $$res;
            });
    }
    public matchfile_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<file_$0> {
        return this.run<file_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<root_statement>;
                let $$res: Nullable<file_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchroot_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.file_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchroot_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement> {
        return this.choice<root_statement>([
            () => this.matchroot_statement_1($$dpth + 1, $$cr),
            () => this.matchroot_statement_2($$dpth + 1, $$cr),
            () => this.matchroot_statement_3($$dpth + 1, $$cr),
            () => this.matchroot_statement_4($$dpth + 1, $$cr),
            () => this.matchroot_statement_5($$dpth + 1, $$cr),
            () => this.matchroot_statement_6($$dpth + 1, $$cr),
            () => this.matchroot_statement_7($$dpth + 1, $$cr),
            () => this.matchroot_statement_8($$dpth + 1, $$cr),
        ]);
    }
    public matchroot_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_1> {
        return this.matchnamespace($$dpth + 1, $$cr);
    }
    public matchroot_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_2> {
        return this.matchextern_definition($$dpth + 1, $$cr);
    }
    public matchroot_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_3> {
        return this.matchtype_definition($$dpth + 1, $$cr);
    }
    public matchroot_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_4> {
        return this.matchimport_statement($$dpth + 1, $$cr);
    }
    public matchroot_statement_5($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_5> {
        return this.matchinterface_definition($$dpth + 1, $$cr);
    }
    public matchroot_statement_6($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_6> {
        return this.matchcomponent($$dpth + 1, $$cr);
    }
    public matchroot_statement_7($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_7> {
        return this.matchsl_comment($$dpth + 1, $$cr);
    }
    public matchroot_statement_8($$dpth: number, $$cr?: ErrorTracker): Nullable<root_statement_8> {
        return this.matchstatement($$dpth + 1, $$cr);
    }
    public matchextern_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<extern_definition> {
        return this.run<extern_definition>($$dpth,
            () => {
                let $scope$type: Nullable<identifier>;
                let $scope$literal: Nullable<dollars>;
                let $$res: Nullable<extern_definition> = null;
                if (true
                    && this.matchEXTERN($$dpth + 1, $$cr) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$type = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$literal = this.matchdollars($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.extern_definition, type: $scope$type, literal: $scope$literal};
                }
                return $$res;
            });
    }
    public matchimport_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<import_statement> {
        return this.run<import_statement>($$dpth,
            () => {
                let $scope$file_name: Nullable<file_name>;
                let $$res: Nullable<import_statement> = null;
                if (true
                    && this.matchIMPORT($$dpth + 1, $$cr) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$file_name = this.matchfile_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.import_statement, file_name: $scope$file_name};
                }
                return $$res;
            });
    }
    public matchfile_name($$dpth: number, $$cr?: ErrorTracker): Nullable<file_name> {
        return this.regexAccept(String.raw`(?:[^;]+)`, "", $$dpth + 1, $$cr);
    }
    public matchtype_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<type_definition> {
        return this.choice<type_definition>([
            () => this.matchtype_definition_1($$dpth + 1, $$cr),
            () => this.matchtype_definition_2($$dpth + 1, $$cr),
            () => this.matchtype_definition_3($$dpth + 1, $$cr),
        ]);
    }
    public matchtype_definition_1($$dpth: number, $$cr?: ErrorTracker): Nullable<type_definition_1> {
        return this.matchenum_definition($$dpth + 1, $$cr);
    }
    public matchtype_definition_2($$dpth: number, $$cr?: ErrorTracker): Nullable<type_definition_2> {
        return this.matchint($$dpth + 1, $$cr);
    }
    public matchtype_definition_3($$dpth: number, $$cr?: ErrorTracker): Nullable<type_definition_3> {
        return this.matchextern_definition($$dpth + 1, $$cr);
    }
    public matchenum_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<enum_definition> {
        return this.run<enum_definition>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $scope$fields: Nullable<fields>;
                let $$res: Nullable<enum_definition> = null;
                if (true
                    && this.matchENUM($$dpth + 1, $$cr) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$fields = this.matchfields($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.enum_definition, name: $scope$name, fields: $scope$fields};
                }
                return $$res;
            });
    }
    public matchfields($$dpth: number, $$cr?: ErrorTracker): Nullable<fields> {
        return this.run<fields>($$dpth,
            () => {
                let $scope$head: Nullable<Nullable<member_identifier>>;
                let $scope$tail: Nullable<fields_$0[]>;
                let $$res: Nullable<fields> = null;
                if (true
                    && (($scope$head = this.matchmember_identifier($$dpth + 1, $$cr)) || true)
                    && ($scope$tail = this.loop<fields_$0>(() => this.matchfields_$0($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = {kind: ASTKinds.fields, head: $scope$head, tail: $scope$tail};
                }
                return $$res;
            });
    }
    public matchfields_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<fields_$0> {
        return this.run<fields_$0>($$dpth,
            () => {
                let $scope$elem: Nullable<Nullable<member_identifier>>;
                let $$res: Nullable<fields_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchCOMMA($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$elem = this.matchmember_identifier($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.fields_$0, elem: $scope$elem};
                }
                return $$res;
            });
    }
    public matchint($$dpth: number, $$cr?: ErrorTracker): Nullable<int> {
        return this.run<int>($$dpth,
            () => {
                let $scope$name: Nullable<compound_name>;
                let $scope$range: Nullable<range>;
                let $$res: Nullable<int> = null;
                if (true
                    && this.matchSUBINT($$dpth + 1, $$cr) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$range = this.matchrange($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.int, name: $scope$name, range: $scope$range};
                }
                return $$res;
            });
    }
    public matchrange($$dpth: number, $$cr?: ErrorTracker): Nullable<range> {
        return this.run<range>($$dpth,
            () => {
                let $scope$from: Nullable<NUMBER>;
                let $scope$to: Nullable<NUMBER>;
                let $$res: Nullable<range> = null;
                if (true
                    && ($scope$from = this.matchNUMBER($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchDOTDOT($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$to = this.matchNUMBER($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.range, from: $scope$from, to: $scope$to};
                }
                return $$res;
            });
    }
    public matchnamespace($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace> {
        return this.run<namespace>($$dpth,
            () => {
                let $scope$name: Nullable<compound_name>;
                let $scope$root: Nullable<namespace_root>;
                let $$res: Nullable<namespace> = null;
                if (true
                    && this.matchNAMESPACE($$dpth + 1, $$cr) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && ($scope$root = this.matchnamespace_root($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.namespace, name: $scope$name, root: $scope$root};
                }
                return $$res;
            });
    }
    public matchnamespace_root($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_root> {
        return this.run<namespace_root>($$dpth,
            () => {
                let $scope$statements: Nullable<namespace_root_$0[]>;
                let $$res: Nullable<namespace_root> = null;
                if (true
                    && ($scope$statements = this.loop<namespace_root_$0>(() => this.matchnamespace_root_$0($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = {kind: ASTKinds.namespace_root, statements: $scope$statements};
                }
                return $$res;
            });
    }
    public matchnamespace_root_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_root_$0> {
        return this.run<namespace_root_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<namespace_statement>;
                let $$res: Nullable<namespace_root_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchnamespace_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.namespace_root_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchnamespace_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement> {
        return this.choice<namespace_statement>([
            () => this.matchnamespace_statement_1($$dpth + 1, $$cr),
            () => this.matchnamespace_statement_2($$dpth + 1, $$cr),
            () => this.matchnamespace_statement_3($$dpth + 1, $$cr),
            () => this.matchnamespace_statement_4($$dpth + 1, $$cr),
        ]);
    }
    public matchnamespace_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_1> {
        return this.matchtype_definition($$dpth + 1, $$cr);
    }
    public matchnamespace_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_2> {
        return this.matchnamespace($$dpth + 1, $$cr);
    }
    public matchnamespace_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_3> {
        return this.matchinterface_definition($$dpth + 1, $$cr);
    }
    public matchnamespace_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<namespace_statement_4> {
        return this.matchcomponent($$dpth + 1, $$cr);
    }
    public matchinterface_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition> {
        return this.run<interface_definition>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $scope$body: Nullable<interface_definition_$0[]>;
                let $scope$behavior: Nullable<Nullable<behavior>>;
                let $$res: Nullable<interface_definition> = null;
                if (true
                    && this.matchINTERFACE($$dpth + 1, $$cr) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$body = this.loop<interface_definition_$0>(() => this.matchinterface_definition_$0($$dpth + 1, $$cr), 0, -1)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$behavior = this.matchbehavior($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.interface_definition, name: $scope$name, body: $scope$body, behavior: $scope$behavior};
                }
                return $$res;
            });
    }
    public matchinterface_definition_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0> {
        return this.run<interface_definition_$0>($$dpth,
            () => {
                let $scope$type_or_event: Nullable<interface_definition_$0_$0>;
                let $$res: Nullable<interface_definition_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$type_or_event = this.matchinterface_definition_$0_$0($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.interface_definition_$0, type_or_event: $scope$type_or_event};
                }
                return $$res;
            });
    }
    public matchinterface_definition_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0_$0> {
        return this.choice<interface_definition_$0_$0>([
            () => this.matchinterface_definition_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchinterface_definition_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchinterface_definition_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0_$0_1> {
        return this.matchtype_definition($$dpth + 1, $$cr);
    }
    public matchinterface_definition_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<interface_definition_$0_$0_2> {
        return this.matchevent($$dpth + 1, $$cr);
    }
    public matchevent($$dpth: number, $$cr?: ErrorTracker): Nullable<event> {
        return this.run<event>($$dpth,
            () => {
                let $scope$direction: Nullable<event_direction>;
                let $scope$type_name: Nullable<compound_name>;
                let $scope$event_name: Nullable<identifier>;
                let $scope$event_params: Nullable<Nullable<event_params>>;
                let $$res: Nullable<event> = null;
                if (true
                    && ($scope$direction = this.matchevent_direction($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$type_name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$event_name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$event_params = this.matchevent_params($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.event, direction: $scope$direction, type_name: $scope$type_name, event_name: $scope$event_name, event_params: $scope$event_params};
                }
                return $$res;
            });
    }
    public matchevent_params($$dpth: number, $$cr?: ErrorTracker): Nullable<event_params> {
        return this.run<event_params>($$dpth,
            () => {
                let $scope$head: Nullable<event_parameter>;
                let $scope$tail: Nullable<event_params_$0[]>;
                let $$res: Nullable<event_params> = null;
                if (true
                    && ($scope$head = this.matchevent_parameter($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<event_params_$0>(() => this.matchevent_params_$0($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = {kind: ASTKinds.event_params, head: $scope$head, tail: $scope$tail};
                }
                return $$res;
            });
    }
    public matchevent_params_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<event_params_$0> {
        return this.run<event_params_$0>($$dpth,
            () => {
                let $scope$elem: Nullable<event_parameter>;
                let $$res: Nullable<event_params_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchCOMMA($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$elem = this.matchevent_parameter($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.event_params_$0, elem: $scope$elem};
                }
                return $$res;
            });
    }
    public matchevent_parameter($$dpth: number, $$cr?: ErrorTracker): Nullable<event_parameter> {
        return this.run<event_parameter>($$dpth,
            () => {
                let $scope$direction: Nullable<Nullable<event_parameter_$0>>;
                let $scope$type: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<event_parameter> = null;
                if (true
                    && (($scope$direction = this.matchevent_parameter_$0($$dpth + 1, $$cr)) || true)
                    && ($scope$type = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.event_parameter, direction: $scope$direction, type: $scope$type, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchevent_parameter_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<event_parameter_$0> {
        return this.run<event_parameter_$0>($$dpth,
            () => {
                let $scope$direction: Nullable<param_direction>;
                let $$res: Nullable<event_parameter_$0> = null;
                if (true
                    && ($scope$direction = this.matchparam_direction($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.event_parameter_$0, direction: $scope$direction};
                }
                return $$res;
            });
    }
    public matchevent_direction($$dpth: number, $$cr?: ErrorTracker): Nullable<event_direction> {
        return this.choice<event_direction>([
            () => this.matchevent_direction_1($$dpth + 1, $$cr),
            () => this.matchevent_direction_2($$dpth + 1, $$cr),
        ]);
    }
    public matchevent_direction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<event_direction_1> {
        return this.matchIN($$dpth + 1, $$cr);
    }
    public matchevent_direction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<event_direction_2> {
        return this.matchOUT($$dpth + 1, $$cr);
    }
    public matchparam_direction($$dpth: number, $$cr?: ErrorTracker): Nullable<param_direction> {
        return this.choice<param_direction>([
            () => this.matchparam_direction_1($$dpth + 1, $$cr),
            () => this.matchparam_direction_2($$dpth + 1, $$cr),
            () => this.matchparam_direction_3($$dpth + 1, $$cr),
        ]);
    }
    public matchparam_direction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<param_direction_1> {
        return this.matchINOUT($$dpth + 1, $$cr);
    }
    public matchparam_direction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<param_direction_2> {
        return this.matchIN($$dpth + 1, $$cr);
    }
    public matchparam_direction_3($$dpth: number, $$cr?: ErrorTracker): Nullable<param_direction_3> {
        return this.matchOUT($$dpth + 1, $$cr);
    }
    public matchcomponent($$dpth: number, $$cr?: ErrorTracker): Nullable<component> {
        return this.run<component>($$dpth,
            () => {
                let $scope$c1: Nullable<__>;
                let $scope$name: Nullable<identifier>;
                let $scope$c2: Nullable<_>;
                let $scope$c3: Nullable<_>;
                let $scope$ports: Nullable<component_$0[]>;
                let $scope$c4: Nullable<_>;
                let $scope$body: Nullable<Nullable<body>>;
                let $scope$c5: Nullable<_>;
                let $$res: Nullable<component> = null;
                if (true
                    && this.matchCOMPONENT($$dpth + 1, $$cr) !== null
                    && ($scope$c1 = this.match__($$dpth + 1, $$cr)) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && ($scope$c2 = this.match_($$dpth + 1, $$cr)) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && ($scope$c3 = this.match_($$dpth + 1, $$cr)) !== null
                    && ($scope$ports = this.loop<component_$0>(() => this.matchcomponent_$0($$dpth + 1, $$cr), 0, -1)) !== null
                    && ($scope$c4 = this.match_($$dpth + 1, $$cr)) !== null
                    && (($scope$body = this.matchbody($$dpth + 1, $$cr)) || true)
                    && ($scope$c5 = this.match_($$dpth + 1, $$cr)) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.component, c1: $scope$c1, name: $scope$name, c2: $scope$c2, c3: $scope$c3, ports: $scope$ports, c4: $scope$c4, body: $scope$body, c5: $scope$c5};
                }
                return $$res;
            });
    }
    public matchcomponent_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<component_$0> {
        return this.run<component_$0>($$dpth,
            () => {
                let $scope$port: Nullable<port>;
                let $$res: Nullable<component_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$port = this.matchport($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.component_$0, port: $scope$port};
                }
                return $$res;
            });
    }
    public matchbody($$dpth: number, $$cr?: ErrorTracker): Nullable<body> {
        return this.choice<body>([
            () => this.matchbody_1($$dpth + 1, $$cr),
            () => this.matchbody_2($$dpth + 1, $$cr),
        ]);
    }
    public matchbody_1($$dpth: number, $$cr?: ErrorTracker): Nullable<body_1> {
        return this.matchbehavior($$dpth + 1, $$cr);
    }
    public matchbody_2($$dpth: number, $$cr?: ErrorTracker): Nullable<body_2> {
        return this.matchsystem($$dpth + 1, $$cr);
    }
    public matchsystem($$dpth: number, $$cr?: ErrorTracker): Nullable<system> {
        return this.run<system>($$dpth,
            () => {
                let $scope$instances_and_bindings: Nullable<system_$0[]>;
                let $$res: Nullable<system> = null;
                if (true
                    && this.matchSYSTEM($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$instances_and_bindings = this.loop<system_$0>(() => this.matchsystem_$0($$dpth + 1, $$cr), 0, -1)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.system, instances_and_bindings: $scope$instances_and_bindings};
                }
                return $$res;
            });
    }
    public matchsystem_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0> {
        return this.run<system_$0>($$dpth,
            () => {
                let $scope$instance_or_binding: Nullable<system_$0_$0>;
                let $$res: Nullable<system_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$instance_or_binding = this.matchsystem_$0_$0($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.system_$0, instance_or_binding: $scope$instance_or_binding};
                }
                return $$res;
            });
    }
    public matchsystem_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0_$0> {
        return this.choice<system_$0_$0>([
            () => this.matchsystem_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchsystem_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchsystem_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0_$0_1> {
        return this.matchinstance($$dpth + 1, $$cr);
    }
    public matchsystem_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<system_$0_$0_2> {
        return this.matchbinding($$dpth + 1, $$cr);
    }
    public matchinstances_and_bindings($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings> {
        return this.loop<instances_and_bindings_$0>(() => this.matchinstances_and_bindings_$0($$dpth + 1, $$cr), 0, -1);
    }
    public matchinstances_and_bindings_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0> {
        return this.run<instances_and_bindings_$0>($$dpth,
            () => {
                let $$res: Nullable<instances_and_bindings_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchinstances_and_bindings_$0_$0($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.instances_and_bindings_$0, };
                }
                return $$res;
            });
    }
    public matchinstances_and_bindings_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0_$0> {
        return this.choice<instances_and_bindings_$0_$0>([
            () => this.matchinstances_and_bindings_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchinstances_and_bindings_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchinstances_and_bindings_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0_$0_1> {
        return this.matchinstance($$dpth + 1, $$cr);
    }
    public matchinstances_and_bindings_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<instances_and_bindings_$0_$0_2> {
        return this.matchbinding($$dpth + 1, $$cr);
    }
    public matchinstance($$dpth: number, $$cr?: ErrorTracker): Nullable<instance> {
        return this.run<instance>($$dpth,
            () => {
                let $scope$type: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<instance> = null;
                if (true
                    && ($scope$type = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.instance, type: $scope$type, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchbinding($$dpth: number, $$cr?: ErrorTracker): Nullable<binding> {
        return this.run<binding>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$left: Nullable<binding_expression>;
                let $scope$right: Nullable<binding_expression>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<binding> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$left = this.matchbinding_expression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBIND($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchbinding_expression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.binding, start: $scope$start, left: $scope$left, right: $scope$right, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchbinding_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression> {
        const fn = () => {
            return this.choice<binding_expression>([
                () => this.matchbinding_expression_1($$dpth + 1, $$cr),
                () => this.matchbinding_expression_2($$dpth + 1, $$cr),
                () => this.matchbinding_expression_3($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$binding_expression$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$binding_expression$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<binding_expression> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$binding_expression$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchbinding_expression_1($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression_1> {
        return this.matchbinding_expression_$0($$dpth + 1, $$cr);
    }
    public matchbinding_expression_2($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression_2> {
        return this.matchidentifier($$dpth + 1, $$cr);
    }
    public matchbinding_expression_3($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression_3> {
        return this.matchasterisk_binding($$dpth + 1, $$cr);
    }
    public matchbinding_expression_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression_$0> {
        return this.run<binding_expression_$0>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$compound: Nullable<binding_expression>;
                let $scope$name: Nullable<binding_expression_$0_$0>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<binding_expression_$0> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$compound = this.matchbinding_expression($$dpth + 1, $$cr)) !== null
                    && this.matchDOT($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchbinding_expression_$0_$0($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.binding_expression_$0, start: $scope$start, compound: $scope$compound, name: $scope$name, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchbinding_expression_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression_$0_$0> {
        return this.choice<binding_expression_$0_$0>([
            () => this.matchbinding_expression_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchbinding_expression_$0_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchbinding_expression_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression_$0_$0_1> {
        return this.matchasterisk_binding($$dpth + 1, $$cr);
    }
    public matchbinding_expression_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<binding_expression_$0_$0_2> {
        return this.matchmember_identifier($$dpth + 1, $$cr);
    }
    public matchasterisk_binding($$dpth: number, $$cr?: ErrorTracker): Nullable<asterisk_binding> {
        return this.run<asterisk_binding>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<asterisk_binding> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && this.matchASTERISK($$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.asterisk_binding, start: $scope$start, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchport($$dpth: number, $$cr?: ErrorTracker): Nullable<port> {
        return this.run<port>($$dpth,
            () => {
                let $scope$direction: Nullable<port_direction>;
                let $scope$qualifiers: Nullable<Nullable<port_qualifiers>>;
                let $scope$type: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<port> = null;
                if (true
                    && ($scope$direction = this.matchport_direction($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && (($scope$qualifiers = this.matchport_qualifiers($$dpth + 1, $$cr)) || true)
                    && ($scope$type = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.port, direction: $scope$direction, qualifiers: $scope$qualifiers, type: $scope$type, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchport_direction($$dpth: number, $$cr?: ErrorTracker): Nullable<port_direction> {
        return this.choice<port_direction>([
            () => this.matchport_direction_1($$dpth + 1, $$cr),
            () => this.matchport_direction_2($$dpth + 1, $$cr),
        ]);
    }
    public matchport_direction_1($$dpth: number, $$cr?: ErrorTracker): Nullable<port_direction_1> {
        return this.matchPROVIDES($$dpth + 1, $$cr);
    }
    public matchport_direction_2($$dpth: number, $$cr?: ErrorTracker): Nullable<port_direction_2> {
        return this.matchREQUIRES($$dpth + 1, $$cr);
    }
    public matchport_qualifiers($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers> {
        return this.loop<port_qualifiers_$0>(() => this.matchport_qualifiers_$0($$dpth + 1, $$cr), 0, -1);
    }
    public matchport_qualifiers_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0> {
        return this.run<port_qualifiers_$0>($$dpth,
            () => {
                let $scope$qualifier: Nullable<port_qualifiers_$0_$0>;
                let $$res: Nullable<port_qualifiers_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$qualifier = this.matchport_qualifiers_$0_$0($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.port_qualifiers_$0, qualifier: $scope$qualifier};
                }
                return $$res;
            });
    }
    public matchport_qualifiers_$0_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0_$0> {
        return this.choice<port_qualifiers_$0_$0>([
            () => this.matchport_qualifiers_$0_$0_1($$dpth + 1, $$cr),
            () => this.matchport_qualifiers_$0_$0_2($$dpth + 1, $$cr),
            () => this.matchport_qualifiers_$0_$0_3($$dpth + 1, $$cr),
        ]);
    }
    public matchport_qualifiers_$0_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0_$0_1> {
        return this.matchEXTERNAL($$dpth + 1, $$cr);
    }
    public matchport_qualifiers_$0_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0_$0_2> {
        return this.matchINJECTED($$dpth + 1, $$cr);
    }
    public matchport_qualifiers_$0_$0_3($$dpth: number, $$cr?: ErrorTracker): Nullable<port_qualifiers_$0_$0_3> {
        return this.matchBLOCKING($$dpth + 1, $$cr);
    }
    public matchformals($$dpth: number, $$cr?: ErrorTracker): Nullable<formals> {
        return this.run<formals>($$dpth,
            () => {
                let $scope$formals: Nullable<Nullable<formal_list>>;
                let $$res: Nullable<formals> = null;
                if (true
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$formals = this.matchformal_list($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.formals, formals: $scope$formals};
                }
                return $$res;
            });
    }
    public matchformal_list($$dpth: number, $$cr?: ErrorTracker): Nullable<formal_list> {
        return this.run<formal_list>($$dpth,
            () => {
                let $scope$head: Nullable<formal>;
                let $scope$tail: Nullable<formal_list_$0[]>;
                let $$res: Nullable<formal_list> = null;
                if (true
                    && ($scope$head = this.matchformal($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<formal_list_$0>(() => this.matchformal_list_$0($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = {kind: ASTKinds.formal_list, head: $scope$head, tail: $scope$tail};
                }
                return $$res;
            });
    }
    public matchformal_list_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<formal_list_$0> {
        return this.run<formal_list_$0>($$dpth,
            () => {
                let $scope$elem: Nullable<formal>;
                let $$res: Nullable<formal_list_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchCOMMA($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$elem = this.matchformal($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.formal_list_$0, elem: $scope$elem};
                }
                return $$res;
            });
    }
    public matchformal($$dpth: number, $$cr?: ErrorTracker): Nullable<formal> {
        return this.run<formal>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$direction: Nullable<Nullable<formal_$0>>;
                let $scope$type_name: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<formal> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && (($scope$direction = this.matchformal_$0($$dpth + 1, $$cr)) || true)
                    && ($scope$type_name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.formal, start: $scope$start, direction: $scope$direction, type_name: $scope$type_name, name: $scope$name, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchformal_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<formal_$0> {
        return this.run<formal_$0>($$dpth,
            () => {
                let $scope$direction: Nullable<param_direction>;
                let $$res: Nullable<formal_$0> = null;
                if (true
                    && ($scope$direction = this.matchparam_direction($$dpth + 1, $$cr)) !== null
                    && this.match__($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.formal_$0, direction: $scope$direction};
                }
                return $$res;
            });
    }
    public matchbehavior($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior> {
        return this.run<behavior>($$dpth,
            () => {
                let $scope$name: Nullable<Nullable<identifier>>;
                let $scope$block: Nullable<behavior_compound>;
                let $$res: Nullable<behavior> = null;
                if (true
                    && this.matchBEHAVIOR($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$name = this.matchidentifier($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$block = this.matchbehavior_compound($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.behavior, name: $scope$name, block: $scope$block};
                }
                return $$res;
            });
    }
    public matchbehavior_compound($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_compound> {
        return this.run<behavior_compound>($$dpth,
            () => {
                let $scope$statements: Nullable<behavior_statements>;
                let $$res: Nullable<behavior_compound> = null;
                if (true
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statements = this.matchbehavior_statements($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.behavior_compound, statements: $scope$statements};
                }
                return $$res;
            });
    }
    public matchbehavior_statements($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statements> {
        return this.loop<behavior_statements_$0>(() => this.matchbehavior_statements_$0($$dpth + 1, $$cr), 0, -1);
    }
    public matchbehavior_statements_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statements_$0> {
        return this.run<behavior_statements_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<behavior_statement>;
                let $$res: Nullable<behavior_statements_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchbehavior_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.behavior_statements_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchbehavior_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement> {
        return this.choice<behavior_statement>([
            () => this.matchbehavior_statement_1($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_2($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_3($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_4($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_5($$dpth + 1, $$cr),
            () => this.matchbehavior_statement_6($$dpth + 1, $$cr),
        ]);
    }
    public matchbehavior_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_1> {
        return this.matchport($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_2> {
        return this.matchfunction_definition($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_3> {
        return this.matchvariable_definition($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_4> {
        return this.matchdeclarative_statement($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_5($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_5> {
        return this.matchtype_definition($$dpth + 1, $$cr);
    }
    public matchbehavior_statement_6($$dpth: number, $$cr?: ErrorTracker): Nullable<behavior_statement_6> {
        return this.matchsl_comment($$dpth + 1, $$cr);
    }
    public matchfunction_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<function_definition> {
        return this.run<function_definition>($$dpth,
            () => {
                let $scope$return_type: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $scope$parameters: Nullable<formals>;
                let $scope$body: Nullable<compound>;
                let $$res: Nullable<function_definition> = null;
                if (true
                    && ($scope$return_type = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$parameters = this.matchformals($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$body = this.matchcompound($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.function_definition, return_type: $scope$return_type, name: $scope$name, parameters: $scope$parameters, body: $scope$body};
                }
                return $$res;
            });
    }
    public matchdeclarative_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement> {
        return this.choice<declarative_statement>([
            () => this.matchdeclarative_statement_1($$dpth + 1, $$cr),
            () => this.matchdeclarative_statement_2($$dpth + 1, $$cr),
            () => this.matchdeclarative_statement_3($$dpth + 1, $$cr),
        ]);
    }
    public matchdeclarative_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement_1> {
        return this.matchon($$dpth + 1, $$cr);
    }
    public matchdeclarative_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement_2> {
        return this.matchguard($$dpth + 1, $$cr);
    }
    public matchdeclarative_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<declarative_statement_3> {
        return this.matchcompound($$dpth + 1, $$cr);
    }
    public matchon($$dpth: number, $$cr?: ErrorTracker): Nullable<on> {
        return this.run<on>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$blocking: Nullable<Nullable<BLOCKING>>;
                let $scope$on_trigger_list: Nullable<on_trigger_list>;
                let $scope$statement: Nullable<statement>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<on> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && (($scope$blocking = this.matchBLOCKING($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchON($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$on_trigger_list = this.matchon_trigger_list($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchCOLON($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchstatement($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.on, start: $scope$start, blocking: $scope$blocking, on_trigger_list: $scope$on_trigger_list, statement: $scope$statement, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchon_trigger_list($$dpth: number, $$cr?: ErrorTracker): Nullable<on_trigger_list> {
        return this.run<on_trigger_list>($$dpth,
            () => {
                let $scope$head: Nullable<Nullable<on_trigger>>;
                let $scope$tail: Nullable<on_trigger_list_$0[]>;
                let $$res: Nullable<on_trigger_list> = null;
                if (true
                    && (($scope$head = this.matchon_trigger($$dpth + 1, $$cr)) || true)
                    && ($scope$tail = this.loop<on_trigger_list_$0>(() => this.matchon_trigger_list_$0($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = {kind: ASTKinds.on_trigger_list, head: $scope$head, tail: $scope$tail};
                }
                return $$res;
            });
    }
    public matchon_trigger_list_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<on_trigger_list_$0> {
        return this.run<on_trigger_list_$0>($$dpth,
            () => {
                let $scope$elem: Nullable<on_trigger>;
                let $$res: Nullable<on_trigger_list_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchCOMMA($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$elem = this.matchon_trigger($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.on_trigger_list_$0, elem: $scope$elem};
                }
                return $$res;
            });
    }
    public matchon_trigger($$dpth: number, $$cr?: ErrorTracker): Nullable<on_trigger> {
        return this.run<on_trigger>($$dpth,
            () => {
                let $scope$name: Nullable<compound_name>;
                let $scope$parameters: Nullable<Nullable<on_formals>>;
                let $$res: Nullable<on_trigger> = null;
                if (true
                    && ($scope$name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$parameters = this.matchon_formals($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.on_trigger, name: $scope$name, parameters: $scope$parameters};
                }
                return $$res;
            });
    }
    public matchon_formals($$dpth: number, $$cr?: ErrorTracker): Nullable<on_formals> {
        return this.run<on_formals>($$dpth,
            () => {
                let $scope$formals: Nullable<Nullable<on_formal_list>>;
                let $$res: Nullable<on_formals> = null;
                if (true
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$formals = this.matchon_formal_list($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.on_formals, formals: $scope$formals};
                }
                return $$res;
            });
    }
    public matchon_formal_list($$dpth: number, $$cr?: ErrorTracker): Nullable<on_formal_list> {
        return this.run<on_formal_list>($$dpth,
            () => {
                let $scope$head: Nullable<on_formal>;
                let $scope$tail: Nullable<on_formal_list_$0[]>;
                let $$res: Nullable<on_formal_list> = null;
                if (true
                    && ($scope$head = this.matchon_formal($$dpth + 1, $$cr)) !== null
                    && ($scope$tail = this.loop<on_formal_list_$0>(() => this.matchon_formal_list_$0($$dpth + 1, $$cr), 0, -1)) !== null
                ) {
                    $$res = {kind: ASTKinds.on_formal_list, head: $scope$head, tail: $scope$tail};
                }
                return $$res;
            });
    }
    public matchon_formal_list_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<on_formal_list_$0> {
        return this.run<on_formal_list_$0>($$dpth,
            () => {
                let $scope$elem: Nullable<on_formal>;
                let $$res: Nullable<on_formal_list_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchCOMMA($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$elem = this.matchon_formal($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.on_formal_list_$0, elem: $scope$elem};
                }
                return $$res;
            });
    }
    public matchon_formal($$dpth: number, $$cr?: ErrorTracker): Nullable<on_formal> {
        return this.run<on_formal>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $scope$assignment: Nullable<Nullable<on_formal_$0>>;
                let $$res: Nullable<on_formal> = null;
                if (true
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$assignment = this.matchon_formal_$0($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.on_formal, name: $scope$name, assignment: $scope$assignment};
                }
                return $$res;
            });
    }
    public matchon_formal_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<on_formal_$0> {
        return this.run<on_formal_$0>($$dpth,
            () => {
                let $scope$name: Nullable<identifier>;
                let $$res: Nullable<on_formal_$0> = null;
                if (true
                    && this.matchLEFT_ARROW($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.on_formal_$0, name: $scope$name};
                }
                return $$res;
            });
    }
    public matchguard($$dpth: number, $$cr?: ErrorTracker): Nullable<guard> {
        return this.run<guard>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$blocking: Nullable<Nullable<BLOCKING>>;
                let $scope$condition: Nullable<Nullable<guard_$0>>;
                let $scope$statement: Nullable<statement>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<guard> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && (($scope$blocking = this.matchBLOCKING($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACKET_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$condition = this.matchguard_$0($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACKET_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchstatement($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.guard, start: $scope$start, blocking: $scope$blocking, condition: $scope$condition, statement: $scope$statement, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchguard_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<guard_$0> {
        return this.choice<guard_$0>([
            () => this.matchguard_$0_1($$dpth + 1, $$cr),
            () => this.matchguard_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchguard_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<guard_$0_1> {
        return this.matchOTHERWISE($$dpth + 1, $$cr);
    }
    public matchguard_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<guard_$0_2> {
        return this.matchexpression($$dpth + 1, $$cr);
    }
    public matchcompound($$dpth: number, $$cr?: ErrorTracker): Nullable<compound> {
        return this.run<compound>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$blocking: Nullable<Nullable<BLOCKING>>;
                let $scope$statements: Nullable<statements>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<compound> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && (($scope$blocking = this.matchBLOCKING($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statements = this.matchstatements($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchBRACE_CLOSE($$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.compound, start: $scope$start, blocking: $scope$blocking, statements: $scope$statements, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchstatements($$dpth: number, $$cr?: ErrorTracker): Nullable<statements> {
        return this.loop<statements_$0>(() => this.matchstatements_$0($$dpth + 1, $$cr), 0, -1);
    }
    public matchstatements_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<statements_$0> {
        return this.run<statements_$0>($$dpth,
            () => {
                let $scope$statement: Nullable<statement>;
                let $$res: Nullable<statements_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchstatement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.statements_$0, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchstatement($$dpth: number, $$cr?: ErrorTracker): Nullable<statement> {
        return this.choice<statement>([
            () => this.matchstatement_1($$dpth + 1, $$cr),
            () => this.matchstatement_2($$dpth + 1, $$cr),
        ]);
    }
    public matchstatement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<statement_1> {
        return this.matchdeclarative_statement($$dpth + 1, $$cr);
    }
    public matchstatement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<statement_2> {
        return this.matchimperative_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement> {
        return this.choice<imperative_statement>([
            () => this.matchimperative_statement_1($$dpth + 1, $$cr),
            () => this.matchimperative_statement_2($$dpth + 1, $$cr),
            () => this.matchimperative_statement_3($$dpth + 1, $$cr),
            () => this.matchimperative_statement_4($$dpth + 1, $$cr),
            () => this.matchimperative_statement_5($$dpth + 1, $$cr),
            () => this.matchimperative_statement_6($$dpth + 1, $$cr),
            () => this.matchimperative_statement_7($$dpth + 1, $$cr),
            () => this.matchimperative_statement_8($$dpth + 1, $$cr),
        ]);
    }
    public matchimperative_statement_1($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_1> {
        return this.matchif_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement_2($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_2> {
        return this.matchreturn_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement_3($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_3> {
        return this.matchvariable_definition($$dpth + 1, $$cr);
    }
    public matchimperative_statement_4($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_4> {
        return this.matchassignment($$dpth + 1, $$cr);
    }
    public matchimperative_statement_5($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_5> {
        return this.matchdefer_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement_6($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_6> {
        return this.matchexpression_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement_7($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_7> {
        return this.matchdollar_statement($$dpth + 1, $$cr);
    }
    public matchimperative_statement_8($$dpth: number, $$cr?: ErrorTracker): Nullable<imperative_statement_8> {
        return this.matchcompound($$dpth + 1, $$cr);
    }
    public matchassignment($$dpth: number, $$cr?: ErrorTracker): Nullable<assignment> {
        return this.run<assignment>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$left: Nullable<identifier>;
                let $scope$right: Nullable<expression>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<assignment> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$left = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchASSIGN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.assignment, start: $scope$start, left: $scope$left, right: $scope$right, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchdefer_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<defer_statement> {
        return this.run<defer_statement>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$header: Nullable<defer_header>;
                let $scope$statement: Nullable<imperative_statement>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<defer_statement> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$header = this.matchdefer_header($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchimperative_statement($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.defer_statement, start: $scope$start, header: $scope$header, statement: $scope$statement, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchdefer_header($$dpth: number, $$cr?: ErrorTracker): Nullable<defer_header> {
        return this.run<defer_header>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$arguments: Nullable<Nullable<defer_arguments>>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<defer_header> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && this.matchDEFER($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$arguments = this.matchdefer_arguments($$dpth + 1, $$cr)) || true)
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.defer_header, start: $scope$start, arguments: $scope$arguments, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchdefer_arguments($$dpth: number, $$cr?: ErrorTracker): Nullable<defer_arguments> {
        return this.run<defer_arguments>($$dpth,
            () => {
                let $scope$arguments: Nullable<arguments>;
                let $$res: Nullable<defer_arguments> = null;
                if (true
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && ($scope$arguments = this.matcharguments($$dpth + 1, $$cr)) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.defer_arguments, arguments: $scope$arguments};
                }
                return $$res;
            });
    }
    public matchdollar_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<dollar_statement> {
        return this.run<dollar_statement>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$expression: Nullable<dollars>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<dollar_statement> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$expression = this.matchdollars($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.dollar_statement, start: $scope$start, expression: $scope$expression, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchexpression_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_statement> {
        return this.run<expression_statement>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$expression: Nullable<expression>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<expression_statement> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.expression_statement, start: $scope$start, expression: $scope$expression, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchif_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<if_statement> {
        return this.run<if_statement>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$expression: Nullable<expression>;
                let $scope$statement: Nullable<imperative_statement>;
                let $scope$else_statements: Nullable<else_statement[]>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<if_statement> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && this.matchIF($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchimperative_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$else_statements = this.loop<else_statement>(() => this.matchelse_statement($$dpth + 1, $$cr), 0, -1)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.if_statement, start: $scope$start, expression: $scope$expression, statement: $scope$statement, else_statements: $scope$else_statements, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchelse_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<else_statement> {
        return this.run<else_statement>($$dpth,
            () => {
                let $scope$elseif: Nullable<Nullable<else_statement_$0>>;
                let $scope$statement: Nullable<imperative_statement>;
                let $$res: Nullable<else_statement> = null;
                if (true
                    && this.matchELSE($$dpth + 1, $$cr) !== null
                    && (($scope$elseif = this.matchelse_statement_$0($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$statement = this.matchimperative_statement($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.else_statement, elseif: $scope$elseif, statement: $scope$statement};
                }
                return $$res;
            });
    }
    public matchelse_statement_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<else_statement_$0> {
        return this.run<else_statement_$0>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<else_statement_$0> = null;
                if (true
                    && this.match__($$dpth + 1, $$cr) !== null
                    && this.matchIF($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.else_statement_$0, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchvariable_definition($$dpth: number, $$cr?: ErrorTracker): Nullable<variable_definition> {
        return this.run<variable_definition>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$type_name: Nullable<compound_name>;
                let $scope$name: Nullable<identifier>;
                let $scope$initializer: Nullable<Nullable<variable_definition_$0>>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<variable_definition> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$type_name = this.matchcompound_name($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchidentifier($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$initializer = this.matchvariable_definition_$0($$dpth + 1, $$cr)) || true)
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.variable_definition, start: $scope$start, type_name: $scope$type_name, name: $scope$name, initializer: $scope$initializer, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchvariable_definition_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<variable_definition_$0> {
        return this.run<variable_definition_$0>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<variable_definition_$0> = null;
                if (true
                    && this.matchASSIGN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.variable_definition_$0, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchreturn_statement($$dpth: number, $$cr?: ErrorTracker): Nullable<return_statement> {
        return this.run<return_statement>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$expression: Nullable<Nullable<expression>>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<return_statement> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && this.matchRETURN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && (($scope$expression = this.matchexpression($$dpth + 1, $$cr)) || true)
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchSEMICOLON($$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.return_statement, start: $scope$start, expression: $scope$expression, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchexpression($$dpth: number, $$cr?: ErrorTracker): Nullable<expression> {
        const fn = () => {
            return this.choice<expression>([
                () => this.matchexpression_1($$dpth + 1, $$cr),
                () => this.matchexpression_2($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$expression$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$expression$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<expression> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$expression$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchexpression_1($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_1> {
        return this.matchbinary_expression($$dpth + 1, $$cr);
    }
    public matchexpression_2($$dpth: number, $$cr?: ErrorTracker): Nullable<expression_2> {
        return this.matchunary_expression($$dpth + 1, $$cr);
    }
    public matchbinary_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_expression> {
        return this.run<binary_expression>($$dpth,
            () => {
                let $scope$left: Nullable<unary_expression>;
                let $scope$operator: Nullable<binary_operator>;
                let $scope$right: Nullable<expression>;
                let $$res: Nullable<binary_expression> = null;
                if (true
                    && ($scope$left = this.matchunary_expression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$operator = this.matchbinary_operator($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$right = this.matchexpression($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.binary_expression, left: $scope$left, operator: $scope$operator, right: $scope$right};
                }
                return $$res;
            });
    }
    public matchbinary_operator($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator> {
        return this.choice<binary_operator>([
            () => this.matchbinary_operator_1($$dpth + 1, $$cr),
            () => this.matchbinary_operator_2($$dpth + 1, $$cr),
            () => this.matchbinary_operator_3($$dpth + 1, $$cr),
            () => this.matchbinary_operator_4($$dpth + 1, $$cr),
            () => this.matchbinary_operator_5($$dpth + 1, $$cr),
            () => this.matchbinary_operator_6($$dpth + 1, $$cr),
            () => this.matchbinary_operator_7($$dpth + 1, $$cr),
            () => this.matchbinary_operator_8($$dpth + 1, $$cr),
            () => this.matchbinary_operator_9($$dpth + 1, $$cr),
            () => this.matchbinary_operator_10($$dpth + 1, $$cr),
        ]);
    }
    public matchbinary_operator_1($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_1> {
        return this.matchAND($$dpth + 1, $$cr);
    }
    public matchbinary_operator_2($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_2> {
        return this.matchOR($$dpth + 1, $$cr);
    }
    public matchbinary_operator_3($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_3> {
        return this.matchEQUAL($$dpth + 1, $$cr);
    }
    public matchbinary_operator_4($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_4> {
        return this.matchNOT_EQUAL($$dpth + 1, $$cr);
    }
    public matchbinary_operator_5($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_5> {
        return this.matchLESS_EQUAL($$dpth + 1, $$cr);
    }
    public matchbinary_operator_6($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_6> {
        return this.matchLESS($$dpth + 1, $$cr);
    }
    public matchbinary_operator_7($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_7> {
        return this.matchGREATER_EQUAL($$dpth + 1, $$cr);
    }
    public matchbinary_operator_8($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_8> {
        return this.matchGREATER($$dpth + 1, $$cr);
    }
    public matchbinary_operator_9($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_9> {
        return this.matchPLUS($$dpth + 1, $$cr);
    }
    public matchbinary_operator_10($$dpth: number, $$cr?: ErrorTracker): Nullable<binary_operator_10> {
        return this.matchMINUS($$dpth + 1, $$cr);
    }
    public matchunary_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression> {
        return this.choice<unary_expression>([
            () => this.matchunary_expression_1($$dpth + 1, $$cr),
            () => this.matchunary_expression_2($$dpth + 1, $$cr),
            () => this.matchunary_expression_3($$dpth + 1, $$cr),
            () => this.matchunary_expression_4($$dpth + 1, $$cr),
            () => this.matchunary_expression_5($$dpth + 1, $$cr),
            () => this.matchunary_expression_6($$dpth + 1, $$cr),
            () => this.matchunary_expression_7($$dpth + 1, $$cr),
            () => this.matchunary_expression_8($$dpth + 1, $$cr),
        ]);
    }
    public matchunary_expression_1($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_1> {
        return this.matchparenthesized_expression($$dpth + 1, $$cr);
    }
    public matchunary_expression_2($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_2> {
        return this.matchproperty_expression($$dpth + 1, $$cr);
    }
    public matchunary_expression_3($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_3> {
        return this.matchcall_expression($$dpth + 1, $$cr);
    }
    public matchunary_expression_4($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_4> {
        return this.matchdollars($$dpth + 1, $$cr);
    }
    public matchunary_expression_5($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_5> {
        return this.matchILLEGAL($$dpth + 1, $$cr);
    }
    public matchunary_expression_6($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_6> {
        return this.matchidentifier($$dpth + 1, $$cr);
    }
    public matchunary_expression_7($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_7> {
        return this.matchnumeric_literal($$dpth + 1, $$cr);
    }
    public matchunary_expression_8($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_expression_8> {
        return this.matchunary_operator_expression($$dpth + 1, $$cr);
    }
    public matchcall_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<call_expression> {
        return this.run<call_expression>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $scope$arguments: Nullable<arguments>;
                let $$res: Nullable<call_expression> = null;
                if (true
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && ($scope$arguments = this.matcharguments($$dpth + 1, $$cr)) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.call_expression, expression: $scope$expression, arguments: $scope$arguments};
                }
                return $$res;
            });
    }
    public matcharguments($$dpth: number, $$cr?: ErrorTracker): Nullable<arguments> {
        return this.loop<arguments_$0>(() => this.matcharguments_$0($$dpth + 1, $$cr), 0, -1);
    }
    public matcharguments_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<arguments_$0> {
        return this.run<arguments_$0>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<arguments_$0> = null;
                if (true
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ((this.matchCOMMA($$dpth + 1, $$cr)) || true)
                ) {
                    $$res = {kind: ASTKinds.arguments_$0, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchdollars($$dpth: number, $$cr?: ErrorTracker): Nullable<dollars> {
        return this.run<dollars>($$dpth,
            () => {
                let $scope$value: Nullable<string>;
                let $$res: Nullable<dollars> = null;
                if (true
                    && this.matchDOLLAR($$dpth + 1, $$cr) !== null
                    && ($scope$value = this.regexAccept(String.raw`(?:[^$]*)`, "", $$dpth + 1, $$cr)) !== null
                    && this.matchDOLLAR($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.dollars, value: $scope$value};
                }
                return $$res;
            });
    }
    public matchnumeric_literal($$dpth: number, $$cr?: ErrorTracker): Nullable<numeric_literal> {
        return this.run<numeric_literal>($$dpth,
            () => {
                let $scope$text: Nullable<NUMBER>;
                let $$res: Nullable<numeric_literal> = null;
                if (true
                    && ($scope$text = this.matchNUMBER($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.numeric_literal, text: $scope$text};
                }
                return $$res;
            });
    }
    public matchparenthesized_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<parenthesized_expression> {
        return this.run<parenthesized_expression>($$dpth,
            () => {
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<parenthesized_expression> = null;
                if (true
                    && this.matchPAREN_OPEN($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && this.matchPAREN_CLOSE($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.parenthesized_expression, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchproperty_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<property_expression> {
        return this.run<property_expression>($$dpth,
            () => {
                let $scope$expression: Nullable<Nullable<expression>>;
                let $scope$access_name: Nullable<member_identifier>;
                let $$res: Nullable<property_expression> = null;
                if (true
                    && (($scope$expression = this.matchexpression($$dpth + 1, $$cr)) || true)
                    && this.matchDOT($$dpth + 1, $$cr) !== null
                    && ($scope$access_name = this.matchmember_identifier($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.property_expression, expression: $scope$expression, access_name: $scope$access_name};
                }
                return $$res;
            });
    }
    public matchunary_operator_expression($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_operator_expression> {
        return this.run<unary_operator_expression>($$dpth,
            () => {
                let $scope$operator: Nullable<unary_operator>;
                let $scope$expression: Nullable<expression>;
                let $$res: Nullable<unary_operator_expression> = null;
                if (true
                    && ($scope$operator = this.matchunary_operator($$dpth + 1, $$cr)) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                    && ($scope$expression = this.matchexpression($$dpth + 1, $$cr)) !== null
                ) {
                    $$res = {kind: ASTKinds.unary_operator_expression, operator: $scope$operator, expression: $scope$expression};
                }
                return $$res;
            });
    }
    public matchunary_operator($$dpth: number, $$cr?: ErrorTracker): Nullable<unary_operator> {
        return this.matchNOT($$dpth + 1, $$cr);
    }
    public matchcompound_name($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name> {
        const fn = () => {
            return this.choice<compound_name>([
                () => this.matchcompound_name_1($$dpth + 1, $$cr),
                () => this.matchcompound_name_2($$dpth + 1, $$cr),
            ]);
        };
        const $scope$pos = this.mark();
        const memo = this.$scope$compound_name$memo.get($scope$pos.overallPos);
        if(memo !== undefined) {
            this.reset(memo[1]);
            return memo[0];
        }
        const $scope$oldMemoSafe = this.memoSafe;
        this.memoSafe = false;
        this.$scope$compound_name$memo.set($scope$pos.overallPos, [null, $scope$pos]);
        let lastRes: Nullable<compound_name> = null;
        let lastPos: PosInfo = $scope$pos;
        for(;;) {
            this.reset($scope$pos);
            const res = fn();
            const end = this.mark();
            if(end.overallPos <= lastPos.overallPos)
                break;
            lastRes = res;
            lastPos = end;
            this.$scope$compound_name$memo.set($scope$pos.overallPos, [lastRes, lastPos]);
        }
        this.reset(lastPos);
        this.memoSafe = $scope$oldMemoSafe;
        return lastRes;
    }
    public matchcompound_name_1($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name_1> {
        return this.matchcompound_name_$0($$dpth + 1, $$cr);
    }
    public matchcompound_name_2($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name_2> {
        return this.matchidentifier($$dpth + 1, $$cr);
    }
    public matchcompound_name_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<compound_name_$0> {
        return this.run<compound_name_$0>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$compound: Nullable<Nullable<compound_name>>;
                let $scope$name: Nullable<member_identifier>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<compound_name_$0> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && (($scope$compound = this.matchcompound_name($$dpth + 1, $$cr)) || true)
                    && this.matchDOT($$dpth + 1, $$cr) !== null
                    && ($scope$name = this.matchmember_identifier($$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.compound_name_$0, start: $scope$start, compound: $scope$compound, name: $scope$name, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchidentifier($$dpth: number, $$cr?: ErrorTracker): Nullable<identifier> {
        return this.run<identifier>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$text: Nullable<string>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<identifier> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$text = this.regexAccept(String.raw`(?:[a-zA-Z_][a-zA-Z0-9_]*)`, "", $$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.identifier, start: $scope$start, text: $scope$text, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchmember_identifier($$dpth: number, $$cr?: ErrorTracker): Nullable<member_identifier> {
        return this.run<member_identifier>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$text: Nullable<string>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<member_identifier> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && ($scope$text = this.regexAccept(String.raw`(?:[a-zA-Z0-9_]+)`, "", $$dpth + 1, $$cr)) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.member_identifier, start: $scope$start, text: $scope$text, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchNUMBER($$dpth: number, $$cr?: ErrorTracker): Nullable<NUMBER> {
        return this.run<NUMBER>($$dpth,
            () => {
                let $$res: Nullable<NUMBER> = null;
                if (true
                    && ((this.matchMINUS($$dpth + 1, $$cr)) || true)
                    && this.regexAccept(String.raw`(?:[0-9]+)`, "", $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.NUMBER, };
                }
                return $$res;
            });
    }
    public matchASTERISK($$dpth: number, $$cr?: ErrorTracker): Nullable<ASTERISK> {
        return this.regexAccept(String.raw`(?:\*)`, "", $$dpth + 1, $$cr);
    }
    public matchDOLLAR($$dpth: number, $$cr?: ErrorTracker): Nullable<DOLLAR> {
        return this.regexAccept(String.raw`(?:\$)`, "", $$dpth + 1, $$cr);
    }
    public matchBRACE_OPEN($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACE_OPEN> {
        return this.regexAccept(String.raw`(?:{)`, "", $$dpth + 1, $$cr);
    }
    public matchBRACE_CLOSE($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACE_CLOSE> {
        return this.regexAccept(String.raw`(?:})`, "", $$dpth + 1, $$cr);
    }
    public matchBRACKET_OPEN($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACKET_OPEN> {
        return this.regexAccept(String.raw`(?:\[)`, "", $$dpth + 1, $$cr);
    }
    public matchBRACKET_CLOSE($$dpth: number, $$cr?: ErrorTracker): Nullable<BRACKET_CLOSE> {
        return this.regexAccept(String.raw`(?:\])`, "", $$dpth + 1, $$cr);
    }
    public matchPAREN_OPEN($$dpth: number, $$cr?: ErrorTracker): Nullable<PAREN_OPEN> {
        return this.regexAccept(String.raw`(?:\()`, "", $$dpth + 1, $$cr);
    }
    public matchPAREN_CLOSE($$dpth: number, $$cr?: ErrorTracker): Nullable<PAREN_CLOSE> {
        return this.regexAccept(String.raw`(?:\))`, "", $$dpth + 1, $$cr);
    }
    public matchSEMICOLON($$dpth: number, $$cr?: ErrorTracker): Nullable<SEMICOLON> {
        return this.regexAccept(String.raw`(?:;)`, "", $$dpth + 1, $$cr);
    }
    public matchCOLON($$dpth: number, $$cr?: ErrorTracker): Nullable<COLON> {
        return this.regexAccept(String.raw`(?::)`, "", $$dpth + 1, $$cr);
    }
    public matchDOT($$dpth: number, $$cr?: ErrorTracker): Nullable<DOT> {
        return this.regexAccept(String.raw`(?:\.)`, "", $$dpth + 1, $$cr);
    }
    public matchDOTDOT($$dpth: number, $$cr?: ErrorTracker): Nullable<DOTDOT> {
        return this.regexAccept(String.raw`(?:\.\.)`, "", $$dpth + 1, $$cr);
    }
    public matchCOMMA($$dpth: number, $$cr?: ErrorTracker): Nullable<COMMA> {
        return this.regexAccept(String.raw`(?:,)`, "", $$dpth + 1, $$cr);
    }
    public matchBIND($$dpth: number, $$cr?: ErrorTracker): Nullable<BIND> {
        return this.regexAccept(String.raw`(?:<=>)`, "", $$dpth + 1, $$cr);
    }
    public matchASSIGN($$dpth: number, $$cr?: ErrorTracker): Nullable<ASSIGN> {
        return this.regexAccept(String.raw`(?:=)`, "", $$dpth + 1, $$cr);
    }
    public matchLEFT_ARROW($$dpth: number, $$cr?: ErrorTracker): Nullable<LEFT_ARROW> {
        return this.regexAccept(String.raw`(?:<-)`, "", $$dpth + 1, $$cr);
    }
    public matchOR($$dpth: number, $$cr?: ErrorTracker): Nullable<OR> {
        return this.regexAccept(String.raw`(?:\|\|)`, "", $$dpth + 1, $$cr);
    }
    public matchAND($$dpth: number, $$cr?: ErrorTracker): Nullable<AND> {
        return this.regexAccept(String.raw`(?:&&)`, "", $$dpth + 1, $$cr);
    }
    public matchEQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<EQUAL> {
        return this.regexAccept(String.raw`(?:==)`, "", $$dpth + 1, $$cr);
    }
    public matchNOT_EQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<NOT_EQUAL> {
        return this.regexAccept(String.raw`(?:!=)`, "", $$dpth + 1, $$cr);
    }
    public matchLESS($$dpth: number, $$cr?: ErrorTracker): Nullable<LESS> {
        return this.regexAccept(String.raw`(?:<)`, "", $$dpth + 1, $$cr);
    }
    public matchLESS_EQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<LESS_EQUAL> {
        return this.regexAccept(String.raw`(?:<=)`, "", $$dpth + 1, $$cr);
    }
    public matchGREATER($$dpth: number, $$cr?: ErrorTracker): Nullable<GREATER> {
        return this.regexAccept(String.raw`(?:>)`, "", $$dpth + 1, $$cr);
    }
    public matchGREATER_EQUAL($$dpth: number, $$cr?: ErrorTracker): Nullable<GREATER_EQUAL> {
        return this.regexAccept(String.raw`(?:>=)`, "", $$dpth + 1, $$cr);
    }
    public matchPLUS($$dpth: number, $$cr?: ErrorTracker): Nullable<PLUS> {
        return this.regexAccept(String.raw`(?:\+)`, "", $$dpth + 1, $$cr);
    }
    public matchMINUS($$dpth: number, $$cr?: ErrorTracker): Nullable<MINUS> {
        return this.regexAccept(String.raw`(?:-)`, "", $$dpth + 1, $$cr);
    }
    public matchNOT($$dpth: number, $$cr?: ErrorTracker): Nullable<NOT> {
        return this.regexAccept(String.raw`(?:!)`, "", $$dpth + 1, $$cr);
    }
    public matchCOMPARE($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE> {
        return this.choice<COMPARE>([
            () => this.matchCOMPARE_1($$dpth + 1, $$cr),
            () => this.matchCOMPARE_2($$dpth + 1, $$cr),
            () => this.matchCOMPARE_3($$dpth + 1, $$cr),
            () => this.matchCOMPARE_4($$dpth + 1, $$cr),
            () => this.matchCOMPARE_5($$dpth + 1, $$cr),
            () => this.matchCOMPARE_6($$dpth + 1, $$cr),
        ]);
    }
    public matchCOMPARE_1($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_1> {
        return this.matchEQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_2($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_2> {
        return this.matchNOT_EQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_3($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_3> {
        return this.matchLESS_EQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_4($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_4> {
        return this.matchLESS($$dpth + 1, $$cr);
    }
    public matchCOMPARE_5($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_5> {
        return this.matchGREATER_EQUAL($$dpth + 1, $$cr);
    }
    public matchCOMPARE_6($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPARE_6> {
        return this.matchGREATER($$dpth + 1, $$cr);
    }
    public matchBEHAVIOR($$dpth: number, $$cr?: ErrorTracker): Nullable<BEHAVIOR> {
        return this.choice<BEHAVIOR>([
            () => this.matchBEHAVIOR_1($$dpth + 1, $$cr),
            () => this.matchBEHAVIOR_2($$dpth + 1, $$cr),
        ]);
    }
    public matchBEHAVIOR_1($$dpth: number, $$cr?: ErrorTracker): Nullable<BEHAVIOR_1> {
        return this.regexAccept(String.raw`(?:behavior)`, "", $$dpth + 1, $$cr);
    }
    public matchBEHAVIOR_2($$dpth: number, $$cr?: ErrorTracker): Nullable<BEHAVIOR_2> {
        return this.regexAccept(String.raw`(?:behaviour)`, "", $$dpth + 1, $$cr);
    }
    public matchBLOCKING($$dpth: number, $$cr?: ErrorTracker): Nullable<BLOCKING> {
        return this.regexAccept(String.raw`(?:blocking)`, "", $$dpth + 1, $$cr);
    }
    public matchBOOL($$dpth: number, $$cr?: ErrorTracker): Nullable<BOOL> {
        return this.regexAccept(String.raw`(?:bool)`, "", $$dpth + 1, $$cr);
    }
    public matchCOMPONENT($$dpth: number, $$cr?: ErrorTracker): Nullable<COMPONENT> {
        return this.regexAccept(String.raw`(?:component)`, "", $$dpth + 1, $$cr);
    }
    public matchDEFER($$dpth: number, $$cr?: ErrorTracker): Nullable<DEFER> {
        return this.regexAccept(String.raw`(?:defer)`, "", $$dpth + 1, $$cr);
    }
    public matchELSE($$dpth: number, $$cr?: ErrorTracker): Nullable<ELSE> {
        return this.regexAccept(String.raw`(?:else)`, "", $$dpth + 1, $$cr);
    }
    public matchENUM($$dpth: number, $$cr?: ErrorTracker): Nullable<ENUM> {
        return this.regexAccept(String.raw`(?:enum)`, "", $$dpth + 1, $$cr);
    }
    public matchEXTERN($$dpth: number, $$cr?: ErrorTracker): Nullable<EXTERN> {
        return this.regexAccept(String.raw`(?:extern)`, "", $$dpth + 1, $$cr);
    }
    public matchEXTERNAL($$dpth: number, $$cr?: ErrorTracker): Nullable<EXTERNAL> {
        return this.regexAccept(String.raw`(?:external)`, "", $$dpth + 1, $$cr);
    }
    public matchFALSE($$dpth: number, $$cr?: ErrorTracker): Nullable<FALSE> {
        return this.regexAccept(String.raw`(?:false)`, "", $$dpth + 1, $$cr);
    }
    public matchIF($$dpth: number, $$cr?: ErrorTracker): Nullable<IF> {
        return this.regexAccept(String.raw`(?:if)`, "", $$dpth + 1, $$cr);
    }
    public matchILLEGAL($$dpth: number, $$cr?: ErrorTracker): Nullable<ILLEGAL> {
        return this.run<ILLEGAL>($$dpth,
            () => {
                let $scope$start: Nullable<PosInfo>;
                let $scope$end: Nullable<PosInfo>;
                let $$res: Nullable<ILLEGAL> = null;
                if (true
                    && ($scope$start = this.mark()) !== null
                    && this.regexAccept(String.raw`(?:illegal)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$end = this.mark()) !== null
                ) {
                    $$res = {kind: ASTKinds.ILLEGAL, start: $scope$start, end: $scope$end};
                }
                return $$res;
            });
    }
    public matchIMPORT($$dpth: number, $$cr?: ErrorTracker): Nullable<IMPORT> {
        return this.regexAccept(String.raw`(?:import)`, "", $$dpth + 1, $$cr);
    }
    public matchIN($$dpth: number, $$cr?: ErrorTracker): Nullable<IN> {
        return this.regexAccept(String.raw`(?:in)`, "", $$dpth + 1, $$cr);
    }
    public matchINEVITABLE($$dpth: number, $$cr?: ErrorTracker): Nullable<INEVITABLE> {
        return this.regexAccept(String.raw`(?:inevitable)`, "", $$dpth + 1, $$cr);
    }
    public matchINJECTED($$dpth: number, $$cr?: ErrorTracker): Nullable<INJECTED> {
        return this.regexAccept(String.raw`(?:injected)`, "", $$dpth + 1, $$cr);
    }
    public matchINOUT($$dpth: number, $$cr?: ErrorTracker): Nullable<INOUT> {
        return this.regexAccept(String.raw`(?:inout)`, "", $$dpth + 1, $$cr);
    }
    public matchINTERFACE($$dpth: number, $$cr?: ErrorTracker): Nullable<INTERFACE> {
        return this.regexAccept(String.raw`(?:interface)`, "", $$dpth + 1, $$cr);
    }
    public matchNAMESPACE($$dpth: number, $$cr?: ErrorTracker): Nullable<NAMESPACE> {
        return this.regexAccept(String.raw`(?:namespace)`, "", $$dpth + 1, $$cr);
    }
    public matchON($$dpth: number, $$cr?: ErrorTracker): Nullable<ON> {
        return this.regexAccept(String.raw`(?:on)`, "", $$dpth + 1, $$cr);
    }
    public matchOPTIONAL($$dpth: number, $$cr?: ErrorTracker): Nullable<OPTIONAL> {
        return this.regexAccept(String.raw`(?:optional)`, "", $$dpth + 1, $$cr);
    }
    public matchOTHERWISE($$dpth: number, $$cr?: ErrorTracker): Nullable<OTHERWISE> {
        return this.regexAccept(String.raw`(?:otherwise)`, "", $$dpth + 1, $$cr);
    }
    public matchOUT($$dpth: number, $$cr?: ErrorTracker): Nullable<OUT> {
        return this.regexAccept(String.raw`(?:out)`, "", $$dpth + 1, $$cr);
    }
    public matchPROVIDES($$dpth: number, $$cr?: ErrorTracker): Nullable<PROVIDES> {
        return this.regexAccept(String.raw`(?:provides)`, "", $$dpth + 1, $$cr);
    }
    public matchREPLY($$dpth: number, $$cr?: ErrorTracker): Nullable<REPLY> {
        return this.regexAccept(String.raw`(?:reply)`, "", $$dpth + 1, $$cr);
    }
    public matchREQUIRES($$dpth: number, $$cr?: ErrorTracker): Nullable<REQUIRES> {
        return this.regexAccept(String.raw`(?:requires)`, "", $$dpth + 1, $$cr);
    }
    public matchRETURN($$dpth: number, $$cr?: ErrorTracker): Nullable<RETURN> {
        return this.regexAccept(String.raw`(?:return)`, "", $$dpth + 1, $$cr);
    }
    public matchSUBINT($$dpth: number, $$cr?: ErrorTracker): Nullable<SUBINT> {
        return this.regexAccept(String.raw`(?:subint)`, "", $$dpth + 1, $$cr);
    }
    public matchSYSTEM($$dpth: number, $$cr?: ErrorTracker): Nullable<SYSTEM> {
        return this.regexAccept(String.raw`(?:system)`, "", $$dpth + 1, $$cr);
    }
    public matchTRUE($$dpth: number, $$cr?: ErrorTracker): Nullable<TRUE> {
        return this.regexAccept(String.raw`(?:true)`, "", $$dpth + 1, $$cr);
    }
    public matchVOID($$dpth: number, $$cr?: ErrorTracker): Nullable<VOID> {
        return this.regexAccept(String.raw`(?:void)`, "", $$dpth + 1, $$cr);
    }
    public matchNEWLINE($$dpth: number, $$cr?: ErrorTracker): Nullable<NEWLINE> {
        return this.regexAccept(String.raw`(?:\n)`, "", $$dpth + 1, $$cr);
    }
    public matchsl_comment($$dpth: number, $$cr?: ErrorTracker): Nullable<sl_comment> {
        return this.run<sl_comment>($$dpth,
            () => {
                let $scope$text: Nullable<string>;
                let $$res: Nullable<sl_comment> = null;
                if (true
                    && ($scope$text = this.regexAccept(String.raw`(?://[^\n]*)`, "", $$dpth + 1, $$cr)) !== null
                    && this.matchsl_comment_$0($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.sl_comment, text: $scope$text};
                }
                return $$res;
            });
    }
    public matchsl_comment_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<sl_comment_$0> {
        return this.choice<sl_comment_$0>([
            () => this.matchsl_comment_$0_1($$dpth + 1, $$cr),
            () => this.matchsl_comment_$0_2($$dpth + 1, $$cr),
        ]);
    }
    public matchsl_comment_$0_1($$dpth: number, $$cr?: ErrorTracker): Nullable<sl_comment_$0_1> {
        return this.regexAccept(String.raw`(?:\n)`, "", $$dpth + 1, $$cr);
    }
    public matchsl_comment_$0_2($$dpth: number, $$cr?: ErrorTracker): Nullable<sl_comment_$0_2> {
        return this.match$EOF($$cr);
    }
    public matchml_comment($$dpth: number, $$cr?: ErrorTracker): Nullable<ml_comment> {
        return this.run<ml_comment>($$dpth,
            () => {
                let $scope$text: Nullable<ml_comment_$0[]>;
                let $$res: Nullable<ml_comment> = null;
                if (true
                    && this.regexAccept(String.raw`(?:/\*)`, "", $$dpth + 1, $$cr) !== null
                    && ($scope$text = this.loop<ml_comment_$0>(() => this.matchml_comment_$0($$dpth + 1, $$cr), 0, -1)) !== null
                    && this.matchml_comment_end($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ml_comment, text: $scope$text};
                }
                return $$res;
            });
    }
    public matchml_comment_$0($$dpth: number, $$cr?: ErrorTracker): Nullable<ml_comment_$0> {
        return this.run<ml_comment_$0>($$dpth,
            () => {
                let $$res: Nullable<ml_comment_$0> = null;
                if (true
                    && this.negate(() => this.matchml_comment_end($$dpth + 1, $$cr)) !== null
                    && this.regexAccept(String.raw`(?:.)`, "", $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ml_comment_$0, };
                }
                return $$res;
            });
    }
    public matchml_comment_end($$dpth: number, $$cr?: ErrorTracker): Nullable<ml_comment_end> {
        return this.run<ml_comment_end>($$dpth,
            () => {
                let $$res: Nullable<ml_comment_end> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\*)`, "", $$dpth + 1, $$cr) !== null
                    && this.regexAccept(String.raw`(?:/)`, "", $$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.ml_comment_end, };
                }
                return $$res;
            });
    }
    public match_($$dpth: number, $$cr?: ErrorTracker): Nullable<_> {
        return this.choice<_>([
            () => this.match__1($$dpth + 1, $$cr),
            () => this.match__2($$dpth + 1, $$cr),
            () => this.match__3($$dpth + 1, $$cr),
        ]);
    }
    public match__1($$dpth: number, $$cr?: ErrorTracker): Nullable<__1> {
        return this.match__$0($$dpth + 1, $$cr);
    }
    public match__2($$dpth: number, $$cr?: ErrorTracker): Nullable<__2> {
        return this.match__$1($$dpth + 1, $$cr);
    }
    public match__3($$dpth: number, $$cr?: ErrorTracker): Nullable<__3> {
        return this.regexAccept(String.raw`(?:\s*)`, "", $$dpth + 1, $$cr);
    }
    public match__$0($$dpth: number, $$cr?: ErrorTracker): Nullable<__$0> {
        return this.run<__$0>($$dpth,
            () => {
                let $$res: Nullable<__$0> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\s*)`, "", $$dpth + 1, $$cr) !== null
                    && this.matchsl_comment($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.__$0, };
                }
                return $$res;
            });
    }
    public match__$1($$dpth: number, $$cr?: ErrorTracker): Nullable<__$1> {
        return this.run<__$1>($$dpth,
            () => {
                let $$res: Nullable<__$1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\s*)`, "", $$dpth + 1, $$cr) !== null
                    && this.matchml_comment($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.__$1, };
                }
                return $$res;
            });
    }
    public match__($$dpth: number, $$cr?: ErrorTracker): Nullable<__> {
        return this.choice<__>([
            () => this.match___1($$dpth + 1, $$cr),
            () => this.match___2($$dpth + 1, $$cr),
            () => this.match___3($$dpth + 1, $$cr),
        ]);
    }
    public match___1($$dpth: number, $$cr?: ErrorTracker): Nullable<___1> {
        return this.match___$0($$dpth + 1, $$cr);
    }
    public match___2($$dpth: number, $$cr?: ErrorTracker): Nullable<___2> {
        return this.match___$1($$dpth + 1, $$cr);
    }
    public match___3($$dpth: number, $$cr?: ErrorTracker): Nullable<___3> {
        return this.regexAccept(String.raw`(?:\s+)`, "", $$dpth + 1, $$cr);
    }
    public match___$0($$dpth: number, $$cr?: ErrorTracker): Nullable<___$0> {
        return this.run<___$0>($$dpth,
            () => {
                let $$res: Nullable<___$0> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\s*)`, "", $$dpth + 1, $$cr) !== null
                    && this.matchsl_comment($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.___$0, };
                }
                return $$res;
            });
    }
    public match___$1($$dpth: number, $$cr?: ErrorTracker): Nullable<___$1> {
        return this.run<___$1>($$dpth,
            () => {
                let $$res: Nullable<___$1> = null;
                if (true
                    && this.regexAccept(String.raw`(?:\s*)`, "", $$dpth + 1, $$cr) !== null
                    && this.matchml_comment($$dpth + 1, $$cr) !== null
                    && this.match_($$dpth + 1, $$cr) !== null
                ) {
                    $$res = {kind: ASTKinds.___$1, };
                }
                return $$res;
            });
    }
    public test(): boolean {
        const mrk = this.mark();
        const res = this.matchfile(0);
        const ans = res !== null;
        this.reset(mrk);
        return ans;
    }
    public parse(): ParseResult {
        const mrk = this.mark();
        const res = this.matchfile(0);
        if (res)
            return {ast: res, errs: []};
        this.reset(mrk);
        const rec = new ErrorTracker();
        this.clearMemos();
        this.matchfile(0, rec);
        const err = rec.getErr()
        return {ast: res, errs: err !== null ? [err] : []}
    }
    public mark(): PosInfo {
        return this.pos;
    }
    // @ts-ignore: loopPlus may not be called
    private loopPlus<T>(func: $$RuleType<T>): Nullable<[T, ...T[]]> {
        return this.loop(func, 1, -1) as Nullable<[T, ...T[]]>;
    }
    private loop<T>(func: $$RuleType<T>, lb: number, ub: number): Nullable<T[]> {
        const mrk = this.mark();
        const res: T[] = [];
        while (ub === -1 || res.length < ub) {
            const preMrk = this.mark();
            const t = func();
            if (t === null || this.pos.overallPos === preMrk.overallPos) {
                break;
            }
            res.push(t);
        }
        if (res.length >= lb) {
            return res;
        }
        this.reset(mrk);
        return null;
    }
    private run<T>($$dpth: number, fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn()
        if (res !== null)
            return res;
        this.reset(mrk);
        return null;
    }
    // @ts-ignore: choice may not be called
    private choice<T>(fns: Array<$$RuleType<T>>): Nullable<T> {
        for (const f of fns) {
            const res = f();
            if (res !== null) {
                return res;
            }
        }
        return null;
    }
    private regexAccept(match: string, mods: string, dpth: number, cr?: ErrorTracker): Nullable<string> {
        return this.run<string>(dpth,
            () => {
                const reg = new RegExp(match, "y" + mods);
                const mrk = this.mark();
                reg.lastIndex = mrk.overallPos;
                const res = this.tryConsume(reg);
                if(cr) {
                    cr.record(mrk, res, {
                        kind: "RegexMatch",
                        // We substring from 3 to len - 1 to strip off the
                        // non-capture group syntax added as a WebKit workaround
                        literal: match.substring(3, match.length - 1),
                        negated: this.negating,
                    });
                }
                return res;
            });
    }
    private tryConsume(reg: RegExp): Nullable<string> {
        const res = reg.exec(this.input);
        if (res) {
            let lineJmp = 0;
            let lind = -1;
            for (let i = 0; i < res[0].length; ++i) {
                if (res[0][i] === "\n") {
                    ++lineJmp;
                    lind = i;
                }
            }
            this.pos = {
                overallPos: reg.lastIndex,
                line: this.pos.line + lineJmp,
                offset: lind === -1 ? this.pos.offset + res[0].length : (res[0].length - lind - 1)
            };
            return res[0];
        }
        return null;
    }
    // @ts-ignore: noConsume may not be called
    private noConsume<T>(fn: $$RuleType<T>): Nullable<T> {
        const mrk = this.mark();
        const res = fn();
        this.reset(mrk);
        return res;
    }
    // @ts-ignore: negate may not be called
    private negate<T>(fn: $$RuleType<T>): Nullable<boolean> {
        const mrk = this.mark();
        const oneg = this.negating;
        this.negating = !oneg;
        const res = fn();
        this.negating = oneg;
        this.reset(mrk);
        return res === null ? true : null;
    }
    // @ts-ignore: Memoise may not be used
    private memoise<K>(rule: $$RuleType<K>, memo: Map<number, [Nullable<K>, PosInfo]>): Nullable<K> {
        const $scope$pos = this.mark();
        const $scope$memoRes = memo.get($scope$pos.overallPos);
        if(this.memoSafe && $scope$memoRes !== undefined) {
        this.reset($scope$memoRes[1]);
        return $scope$memoRes[0];
        }
        const $scope$result = rule();
        if(this.memoSafe)
        memo.set($scope$pos.overallPos, [$scope$result, this.mark()]);
        return $scope$result;
    }
    private match$EOF(et?: ErrorTracker): Nullable<{kind: ASTKinds.$EOF}> {
        const res: {kind: ASTKinds.$EOF} | null = this.finished() ? { kind: ASTKinds.$EOF } : null;
        if(et)
            et.record(this.mark(), res, { kind: "EOF", negated: this.negating });
        return res;
    }
}
export function parse(s: string): ParseResult {
    const p = new Parser(s);
    return p.parse();
}
export interface ParseResult {
    ast: Nullable<file>;
    errs: SyntaxErr[];
}
export interface PosInfo {
    readonly overallPos: number;
    readonly line: number;
    readonly offset: number;
}
export interface RegexMatch {
    readonly kind: "RegexMatch";
    readonly negated: boolean;
    readonly literal: string;
}
export type EOFMatch = { kind: "EOF"; negated: boolean };
export type MatchAttempt = RegexMatch | EOFMatch;
export class SyntaxErr {
    public pos: PosInfo;
    public expmatches: MatchAttempt[];
    constructor(pos: PosInfo, expmatches: MatchAttempt[]) {
        this.pos = pos;
        this.expmatches = [...expmatches];
    }
    public toString(): string {
        return `Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map(x => x.kind === "EOF" ? " EOF" : ` ${x.negated ? 'not ': ''}'${x.literal}'`)}`;
    }
}
class ErrorTracker {
    private mxpos: PosInfo = {overallPos: -1, line: -1, offset: -1};
    private regexset: Set<string> = new Set();
    private pmatches: MatchAttempt[] = [];
    public record(pos: PosInfo, result: any, att: MatchAttempt) {
        if ((result === null) === att.negated)
            return;
        if (pos.overallPos > this.mxpos.overallPos) {
            this.mxpos = pos;
            this.pmatches = [];
            this.regexset.clear()
        }
        if (this.mxpos.overallPos === pos.overallPos) {
            if(att.kind === "RegexMatch") {
                if(!this.regexset.has(att.literal))
                    this.pmatches.push(att);
                this.regexset.add(att.literal);
            } else {
                this.pmatches.push(att);
            }
        }
    }
    public getErr(): SyntaxErr | null {
        if (this.mxpos.overallPos !== -1)
            return new SyntaxErr(this.mxpos, this.pmatches);
        return null;
    }
}