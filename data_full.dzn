// Dezyne --- Dezyne command line tools
//
// Copyright © 2016, 2017, 2020 Jan (janneke) Nieuwenhuizen <janneke@gnu.org>
// Copyright © 2016, 2018 Rutger van Beusekom <rutger@dezyne.org>
//
// This file is part of Dezyne.
//
// Dezyne is free software: you can redistribute it and/or modify it
// under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// Dezyne is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public
// License along with Dezyne.  If not, see <http://www.gnu.org/licenses/>.
//
// Commentary:
//
// Code:

interface Idata_full
{
  extern xint $int$;
  enum Status {Yes, No};

  in void e0 ();
  in Status e0r ();
  in void e (in xint i);
  in Status er (in xint i);
  in Status eer (in xint i, in xint j);

  in void eo(out xint i);
  in void eoo(out xint i, out xint j);
  in void eio(in xint i, out xint j);
  in void eio2(inout xint i);

  in Status eor(out xint i);
  in Status eoor(out xint i, out xint j);
  in Status eior(in xint i, out xint j);
  in Status eio2r(inout xint i);

  out void a0 ();
  out void a (xint i);
  out void aa (in xint i, in xint j);
  out void a6 (in xint a0,in xint a1,in xint a2,in xint a3,in xint a4,in xint a5);

  behavior
  {
    on e0: a6;
    on e0r: {a0;reply(Status.Yes);}
    on e:
    {
      a;
      aa;
    }
    on er:
    {
      a;
      aa;
      reply(Status.Yes);
    }
    on eer:
    {
      a;
      aa;
      reply(Status.No);
    }
    on eo:{}
    on eoo:{}
    on eio:{}
    on eio2:{}

    on eor: { reply(Status.Yes); }
    on eoor: { reply(Status.Yes); }
    on eior: { reply(Status.Yes); }
    on eio2r: { reply(Status.Yes); }
  }
}

component data_full_
{
  provides Idata_full port;

  behavior
  {
    Idata_full.xint mi = $0$;
    Idata_full.Status s = Idata_full.Status.Yes;

    Idata_full.Status fun ()
    {
      return Idata_full.Status.Yes;
    }

    Idata_full.Status funx (Idata_full.xint xi)
    {
      // xi = xi; Java: final parameter may not be assigned
      return Idata_full.Status.Yes;
    }

    // void fun(inout Idata_full.xint i) // TODO inout function
    // {
    //   i = $789$;
    // }

    // Idata_full.xint xfunx (Idata_full.xint xi, Idata_full.xint xj)
    // {
    //   return $(xi + xj) / 2$;
    // }

    on port.e0(): { port.a6($0$,$1$,$2$,$3$,$4$,$5$); }

    on port.e0r(): {port.a0();reply(Idata_full.Status.Yes);}

    on port.e (pi):
    {
      Idata_full.Status s = funx (pi);
      s = s;
      mi = pi;
      // mi = xfunx (pi, $pi + mi$);  // member in $: Ok for C++ but C: self->mi, Python: self.mi
      //mi = xfunx (pi, $pi + pi$); // javascript: foobar NaN
      //mi = xfunx (pi, pi);
      port.a (mi);
      port.aa (mi, pi);
      pi = $0$; // assign in-parameter should not have any effect
    }
    on port.er (pi):
    {
      Idata_full.Status s = Idata_full.Status.No;
      mi = pi;
      port.a (mi);
      port.aa (mi, pi);

      if(true) {
        reply(Idata_full.Status.Yes);
      } else {
        reply(s);
      }
    }
    on port.eer (i,j):
    {
      Idata_full.Status s = Idata_full.Status.No;
      port.a (j);
      port.aa (j, i);
      reply(s);
    }
    on port.eo(i): { i = $234$; }
    on port.eoo(i,j): { i = $123$; j = $456$; }
    on port.eio(i,j): { j = i; }
    // on port.eio2(i): { i = $i + 123$; } // parameter in $: Ok for C++ but C: *i
    // on port.eio2(i): { Idata_full.xint t = i; i = $t + 123$; } // Ok for C, C++; not portable to javascript
    //on port.eio2(i): { Idata_full.xint t = i; i = $123 + 123$; } // Ok for C, C++, Python, Javascript, not portable to Scheme
    on port.eio2(i): { Idata_full.xint t = i; i = $246$; }

    on port.eor(i): { i = $234$; reply(Idata_full.Status.Yes); }
    on port.eoor(i,j): { i = $123$; j = $456$; reply(Idata_full.Status.Yes); }
    on port.eior(i,j): { j = i; reply(Idata_full.Status.Yes); }
    // on port.eio2r(i): { i = $i + 123$; reply(Idata_full.Status.Yes); } // parameter in $: Ok for C++ but C: *i
    // on port.eio2r(i): { Idata_full.xint t = i; i = $t + 123$; reply(Idata_full.Status.Yes); }
    //on port.eio2r(i): { Idata_full.xint t = i; i = $123 + 123$; reply(Idata_full.Status.Yes); }
    on port.eio2r(i): { Idata_full.xint t = i; i = $246$; reply(Idata_full.Status.Yes); }
  }
}

component proxy
{
  provides Idata_full top;
  requires Idata_full bottom;

  behavior
  {
    void outfunc (out Idata_full.xint i)
    {
      Idata_full.xint j = $0$;
      bottom.eo(j);
      i = j;
    }
    void deferfunc (Idata_full.xint i)
    {
      top.a(i);
    }
    on top.e0(): bottom.e0();
    on top.e0r(): reply (bottom.e0r());
    on top.e(pi): bottom.e(pi);
    on top.er(pi): reply (bottom.er (pi));
    on top.eer(i,j): reply (bottom.eer(i,j));

    on top.eo(i): outfunc(i);
    on top.eoo(i,j): bottom.eoo(i,j);
    on top.eio(i,j): bottom.eio(i,j);
    on top.eio2(i): bottom.eio2(i);

    on top.eor(i): reply (bottom.eor(i));
    on top.eoor(i,j): reply (bottom.eoor(i,j));
    on top.eior(i,j): reply (bottom.eior(i,j));
    on top.eio2r(i): reply (bottom.eio2r(i));

    on bottom.a0(): top.a0();
    on bottom.a6(A0,A1,A2,A3,A4,A5): top.a6(A0,A1,A2,A3,A4,A5);
    on bottom.a(i): deferfunc(i);
    on bottom.aa(i,j): top.aa(i,j);
  }
}

component data_full
{
  provides Idata_full port;
  system
  {
    proxy p;
    data_full_ c;

    p.top <=> port;
    c.port <=> p.bottom;
  }
}
